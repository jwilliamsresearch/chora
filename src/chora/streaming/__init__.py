"""
Real-time Streaming for Chora

Live GPS trace handling with WebSocket support for real-time platial updates.
"""
from __future__ import annotations

import asyncio
import json
from dataclasses import dataclass, field
from datetime import datetime
from typing import AsyncIterator, Callable, Any
from collections import deque

from chora.core import PlatialGraph, Agent, SpatialExtent, Encounter, PlatialEdge
from chora.core.types import NodeId, NodeType


# =============================================================================
# Stream Event Types
# =============================================================================

@dataclass
class LocationEvent:
    """A single location update from a GPS stream."""
    
    agent_id: str
    longitude: float
    latitude: float
    timestamp: datetime
    accuracy: float = 0.0
    altitude: float | None = None
    speed: float | None = None
    heading: float | None = None
    metadata: dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> dict:
        return {
            "agent_id": self.agent_id,
            "longitude": self.longitude,
            "latitude": self.latitude,
            "timestamp": self.timestamp.isoformat(),
            "accuracy": self.accuracy,
            "altitude": self.altitude,
            "speed": self.speed,
            "heading": self.heading,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> LocationEvent:
        return cls(
            agent_id=data["agent_id"],
            longitude=data["longitude"],
            latitude=data["latitude"],
            timestamp=datetime.fromisoformat(data["timestamp"]),
            accuracy=data.get("accuracy", 0.0),
            altitude=data.get("altitude"),
            speed=data.get("speed"),
            heading=data.get("heading"),
            metadata=data.get("metadata", {})
        )


@dataclass
class StreamEvent:
    """An event emitted by the streaming processor."""
    
    event_type: str  # location, encounter, dwell, transition
    data: dict[str, Any]
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_json(self) -> str:
        return json.dumps({
            "event_type": self.event_type,
            "data": self.data,
            "timestamp": self.timestamp.isoformat()
        }, default=str)


# =============================================================================
# Stream Processor
# =============================================================================

@dataclass
class StreamConfig:
    """Configuration for stream processing."""
    
    # Dwell detection
    dwell_radius_m: float = 50.0  # Meters for same-place detection
    dwell_time_s: float = 60.0    # Seconds to trigger dwell
    
    # Encounter creation
    min_dwell_for_encounter: float = 120.0  # Seconds
    
    # Buffering
    max_buffer_size: int = 100
    
    # H3 resolution for location snapping
    h3_resolution: int = 10  # ~65m precision


class StreamProcessor:
    """
    Process real-time location streams.
    
    Detects dwells, creates encounters, and emits events.
    """
    
    def __init__(
        self, 
        graph: PlatialGraph, 
        config: StreamConfig | None = None
    ):
        self.graph = graph
        self.config = config or StreamConfig()
        
        # State per agent
        self.agent_states: dict[str, AgentStreamState] = {}
        
        # Event listeners
        self.listeners: list[Callable[[StreamEvent], None]] = []
    
    def add_listener(self, callback: Callable[[StreamEvent], None]) -> None:
        """Add an event listener."""
        self.listeners.append(callback)
    
    def remove_listener(self, callback: Callable[[StreamEvent], None]) -> None:
        """Remove an event listener."""
        self.listeners.remove(callback)
    
    def emit(self, event: StreamEvent) -> None:
        """Emit an event to all listeners."""
        for listener in self.listeners:
            try:
                listener(event)
            except Exception:
                pass
    
    def process(self, location: LocationEvent) -> list[StreamEvent]:
        """
        Process a single location event.
        
        Returns any events generated by this update.
        """
        events = []
        
        # Get or create agent state
        if location.agent_id not in self.agent_states:
            self.agent_states[location.agent_id] = AgentStreamState(
                agent_id=location.agent_id,
                config=self.config
            )
        
        state = self.agent_states[location.agent_id]
        
        # Process through state machine
        new_events = state.update(location, self.graph)
        
        for event in new_events:
            events.append(event)
            self.emit(event)
        
        return events
    
    async def process_stream(
        self, 
        stream: AsyncIterator[LocationEvent]
    ) -> AsyncIterator[StreamEvent]:
        """Process an async stream of locations."""
        async for location in stream:
            events = self.process(location)
            for event in events:
                yield event
    
    def get_agent_state(self, agent_id: str) -> AgentStreamState | None:
        """Get current state for an agent."""
        return self.agent_states.get(agent_id)


@dataclass
class AgentStreamState:
    """
    State machine for tracking an agent's streaming location.
    """
    
    agent_id: str
    config: StreamConfig
    
    # Current state
    current_location: LocationEvent | None = None
    dwell_start: datetime | None = None
    dwell_location: tuple[float, float] | None = None
    last_encounter_extent: str | None = None
    
    # Buffer
    location_buffer: deque = field(default_factory=lambda: deque(maxlen=100))
    
    def update(
        self, 
        location: LocationEvent, 
        graph: PlatialGraph
    ) -> list[StreamEvent]:
        """Update state with new location, return any triggered events."""
        events = []
        
        # Store previous state
        prev_location = self.current_location
        self.current_location = location
        self.location_buffer.append(location)
        
        # Emit location event
        events.append(StreamEvent(
            event_type="location",
            data=location.to_dict(),
            timestamp=location.timestamp
        ))
        
        # Check for dwell
        if self._is_dwelling(location):
            if self.dwell_start is None:
                # Start dwell
                self.dwell_start = location.timestamp
                self.dwell_location = (location.longitude, location.latitude)
            else:
                # Continue dwell - check if long enough for encounter
                dwell_duration = (location.timestamp - self.dwell_start).total_seconds()
                
                if dwell_duration >= self.config.min_dwell_for_encounter:
                    # Create encounter if we haven't already at this location
                    extent_key = f"{location.longitude:.5f},{location.latitude:.5f}"
                    
                    if extent_key != self.last_encounter_extent:
                        encounter_event = self._create_encounter(
                            graph, location, dwell_duration
                        )
                        events.append(encounter_event)
                        self.last_encounter_extent = extent_key
        else:
            # Not dwelling - check for transition
            if self.dwell_start is not None:
                events.append(StreamEvent(
                    event_type="transition",
                    data={
                        "agent_id": self.agent_id,
                        "from": self.dwell_location,
                        "to": (location.longitude, location.latitude),
                        "dwell_duration": (location.timestamp - self.dwell_start).total_seconds()
                    },
                    timestamp=location.timestamp
                ))
                
                self.dwell_start = None
                self.dwell_location = None
        
        return events
    
    def _is_dwelling(self, location: LocationEvent) -> bool:
        """Check if we're dwelling at the current location."""
        if self.dwell_location is None:
            return True  # First point starts a potential dwell
        
        # Calculate distance from dwell point
        dist = self._haversine_distance(
            self.dwell_location[0], self.dwell_location[1],
            location.longitude, location.latitude
        )
        
        return dist < self.config.dwell_radius_m
    
    def _create_encounter(
        self, 
        graph: PlatialGraph,
        location: LocationEvent,
        duration: float
    ) -> StreamEvent:
        """Create an encounter from a dwell."""
        # Find or create extent
        extent = SpatialExtent.from_point(
            location.longitude, 
            location.latitude,
            name=f"loc_{location.longitude:.5f}_{location.latitude:.5f}"
        )
        
        try:
            graph.add_node(extent)
        except Exception:
            pass  # May already exist
        
        # Get or create agent
        agent_id = NodeId(location.agent_id)
        try:
            agent = graph.get_node(agent_id)
        except Exception:
            agent = Agent.individual(location.agent_id)
            graph.add_node(agent)
        
        # Create encounter
        encounter = Encounter(
            agent_id=agent_id,
            extent_id=extent.id,
            start_time=self.dwell_start,
            activity="dwell"
        )
        graph.add_node(encounter)
        graph.add_edge(PlatialEdge.participates_in(agent_id, encounter.id))
        graph.add_edge(PlatialEdge.occurs_at(encounter.id, extent.id))
        
        return StreamEvent(
            event_type="encounter",
            data={
                "agent_id": self.agent_id,
                "extent_id": str(extent.id),
                "duration": duration,
                "location": (location.longitude, location.latitude),
                "encounter_id": str(encounter.id)
            },
            timestamp=location.timestamp
        )
    
    @staticmethod
    def _haversine_distance(lon1: float, lat1: float, lon2: float, lat2: float) -> float:
        """Calculate distance in meters between two points."""
        import math
        
        R = 6371000  # Earth radius in meters
        
        phi1 = math.radians(lat1)
        phi2 = math.radians(lat2)
        dphi = math.radians(lat2 - lat1)
        dlambda = math.radians(lon2 - lon1)
        
        a = math.sin(dphi/2)**2 + math.cos(phi1) * math.cos(phi2) * math.sin(dlambda/2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        
        return R * c


# =============================================================================
# WebSocket Handler
# =============================================================================

async def websocket_handler(websocket, processor: StreamProcessor):
    """
    Handle WebSocket connection for real-time location streaming.
    
    Expected message format:
    {
        "type": "location",
        "agent_id": "...",
        "longitude": -0.1,
        "latitude": 51.5,
        "timestamp": "2024-01-01T12:00:00Z"
    }
    """
    async for message in websocket:
        try:
            data = json.loads(message)
            
            if data.get("type") == "location":
                location = LocationEvent(
                    agent_id=data["agent_id"],
                    longitude=data["longitude"],
                    latitude=data["latitude"],
                    timestamp=datetime.fromisoformat(data["timestamp"]),
                    accuracy=data.get("accuracy", 0),
                    altitude=data.get("altitude"),
                    speed=data.get("speed"),
                    heading=data.get("heading")
                )
                
                events = processor.process(location)
                
                # Send back events
                for event in events:
                    await websocket.send(event.to_json())
        
        except (json.JSONDecodeError, KeyError) as e:
            await websocket.send(json.dumps({
                "error": str(e)
            }))


# =============================================================================
# Convenience Functions
# =============================================================================

def create_processor(
    graph: PlatialGraph,
    dwell_radius: float = 50.0,
    dwell_time: float = 60.0
) -> StreamProcessor:
    """Create a stream processor with custom config."""
    config = StreamConfig(
        dwell_radius_m=dwell_radius,
        dwell_time_s=dwell_time
    )
    return StreamProcessor(graph, config)
