{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>The Python Library for Place-Based Computing</p> <p>Model place as experience, not just location</p> Get Started \u2192 View Guides GitHub <code>pip install chora-geo</code> \ud83c\udfaf What is Chora? <p>Chora is the first Python library to model the human experience of place. Unlike standard GIS which asks \"What is at coordinates X,Y?\", Chora asks \"Why does this park feel like Home to Alice, but Danger to Bob?\"</p> <p>Place isn't a polygon\u2014it's an emergent phenomenon arising from memory, habit, emotion, and social interaction.</p> Encounters Familiarity Practices Affect H3 Indexing LLM Integration \u26a1 Quick Example  from chora.core import * # Create a platial graph graph = PlatialGraph(\"City\") alice = Agent.individual(\"Alice\") park = SpatialExtent.from_point(-0.1, 51.5, \"Park\") # Record an encounter enc = Encounter(agent_id=alice.id, extent_id=park.id) graph.add_node(enc) # Derive familiarity over time update_familiarity(graph, enc)      \u2192 Full tutorial \ud83d\udcda Guides <ul> <li>GPS to Places \u2014 Process traces into meaningful places</li> <li>Affective Mapping \u2014 Map emotions to locations</li> <li>Detecting Routines \u2014 Find habits &amp; patterns</li> <li>Visualization \u2014 D3.js graphs &amp; reports</li> <li>H3 Indexing \u2014 Hexagonal spatial analysis</li> </ul> \ud83d\udd2c Theoretical Foundation <p>Built on rigorous theory from GIScience, cognitive geography, and social physics:</p> <ul> <li>Relational primacy \u2014 Places defined by relations, not coordinates</li> <li>Encounter-centric \u2014 Atomic events as foundation</li> <li>Temporal decay \u2014 Memory fades without reinforcement</li> <li>Epistemic separation \u2014 Different agents, different places</li> </ul> \u2192 Read the theory \ud83d\udee0\ufe0f CLI Tool  # Load GPS data chora load gpx trace.gpx --agent alice # Derive familiarity chora derive familiarity --agent alice # Find routines chora derive practices --agent alice # Visualize chora viz export --format d3 -o graph.html      \u2192 CLI reference \ud83d\udd0d Vibe Search <p>Find places by semantic description using vector embeddings:</p>  from chora.search import vibe_search results = vibe_search(     graph,     \"quiet peaceful park for reading\" ) # Returns: [(park, 0.87), (garden, 0.72), ...]      \u2192 Learn vibe search \ud83d\uddfa\ufe0f Roadmap v0.5 \u2705 Core, Tests, CI/CD, Docs v0.9 \u2705 CLI, Notebooks, Visualization v1.0 \u2705 H3, Embeddings, LLM, Streaming v2.0 \ud83d\udea7 Social Physics, Digital Twins <p> Built for the Platial Turn   Open Source \u2022 MIT License \u2022 GitHub </p>"},{"location":"api_reference/","title":"API Reference","text":"<p>Complete reference for the Chora library.</p>"},{"location":"api_reference/#core-module","title":"Core Module","text":""},{"location":"api_reference/#graph-structure","title":"Graph Structure","text":""},{"location":"api_reference/#chora.core.graph","title":"<code>chora.core.graph</code>","text":"<p>Platial Graph Container</p> <p>The core representation is a typed, temporal, heterogeneous graph that enables multiple, even conflicting experiences to coexist.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph","title":"<code>PlatialGraph</code>  <code>dataclass</code>","text":"<p>A typed, temporal, heterogeneous graph for platial modelling.</p> <p>The graph stores nodes (entities) and edges (relations) with full temporal validity, uncertainty, and provenance tracking.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph--attributes","title":"Attributes","text":"<p>name : str     Optional name for the graph. description : str     Optional description.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph--examples","title":"Examples","text":"<p>from chora.core import PlatialGraph, Agent, SpatialExtent graph = PlatialGraph(name=\"Urban Mobility Study\") agent = Agent(name=\"Alice\") graph.add_node(agent) graph.node_count 1</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.all_node_ids","title":"<code>all_node_ids</code>  <code>property</code>","text":"<p>Get all node IDs.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.edge_count","title":"<code>edge_count</code>  <code>property</code>","text":"<p>Total number of edges.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.node_count","title":"<code>node_count</code>  <code>property</code>","text":"<p>Total number of nodes.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.add_edge","title":"<code>add_edge(edge)</code>","text":"<p>Add an edge to the graph.</p> <p>Both source and target nodes must exist.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.add_edge--raises","title":"Raises","text":"<p>NodeNotFoundError     If source or target node doesn't exist.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.add_node","title":"<code>add_node(node)</code>","text":"<p>Add a node to the graph.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.add_node--parameters","title":"Parameters","text":"<p>node : PlatialNode     The node to add.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.add_node--returns","title":"Returns","text":"<p>NodeId     The ID of the added node.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.add_node--raises","title":"Raises","text":"<p>DuplicateNodeError     If a node with this ID already exists.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.clear","title":"<code>clear()</code>","text":"<p>Remove all nodes and edges.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.edge_count_by_type","title":"<code>edge_count_by_type(edge_type)</code>","text":"<p>Count edges of a specific type.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.edges","title":"<code>edges(edge_type=None)</code>","text":"<p>Iterate over edges, optionally filtered by type.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.get_edge","title":"<code>get_edge(edge_id)</code>","text":"<p>Get an edge by ID.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.get_node","title":"<code>get_node(node_id)</code>","text":"<p>Get a node by ID.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.get_node--raises","title":"Raises","text":"<p>NodeNotFoundError     If the node does not exist.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.has_edge","title":"<code>has_edge(edge_id)</code>","text":"<p>Check if an edge exists.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.has_node","title":"<code>has_node(node_id)</code>","text":"<p>Check if a node exists.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.incoming_edges","title":"<code>incoming_edges(node_id, edge_type=None)</code>","text":"<p>Get edges pointing to a node.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.neighbors","title":"<code>neighbors(node_id, edge_type=None)</code>","text":"<p>Get neighboring nodes (via outgoing edges).</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.node_count_by_type","title":"<code>node_count_by_type(node_type)</code>","text":"<p>Count nodes of a specific type.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.nodes","title":"<code>nodes(node_type=None)</code>","text":"<p>Iterate over nodes, optionally filtered by type.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.nodes--parameters","title":"Parameters","text":"<p>node_type : NodeType | None     If provided, only yield nodes of this type.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.nodes_valid_at","title":"<code>nodes_valid_at(timestamp, node_type=None)</code>","text":"<p>Iterate over nodes valid at a given timestamp.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.outgoing_edges","title":"<code>outgoing_edges(node_id, edge_type=None)</code>","text":"<p>Get edges originating from a node.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.predecessors","title":"<code>predecessors(node_id, edge_type=None)</code>","text":"<p>Get predecessor nodes (via incoming edges).</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.remove_edge","title":"<code>remove_edge(edge_id)</code>","text":"<p>Remove an edge from the graph.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.remove_node","title":"<code>remove_node(node_id)</code>","text":"<p>Remove a node and all its edges.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.remove_node--returns","title":"Returns","text":"<p>PlatialNode     The removed node.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.snapshot","title":"<code>snapshot(timestamp)</code>","text":"<p>Create a snapshot of the graph at a specific time.</p> <p>Only includes nodes and edges valid at that timestamp.</p>"},{"location":"api_reference/#chora.core.graph.PlatialGraph.subgraph","title":"<code>subgraph(node_ids)</code>","text":"<p>Extract a subgraph containing only the specified nodes.</p> <p>Includes all edges where both endpoints are in the subgraph.</p>"},{"location":"api_reference/#types-enumerations","title":"Types &amp; Enumerations","text":""},{"location":"api_reference/#chora.core.types","title":"<code>chora.core.types</code>","text":"<p>Core Type Definitions for Chora</p> <p>This module defines the foundational types, enumerations, and type aliases used throughout the Chora library. These types encode the ontological structure of platial modelling.</p>"},{"location":"api_reference/#chora.core.types--type-categories","title":"Type Categories","text":"<ol> <li>Node Types \u2014 classify entities in the platial graph</li> <li>Edge Types \u2014 classify relations between entities</li> <li>Epistemic Levels \u2014 distinguish data provenance and certainty</li> <li>Context Types \u2014 categorise situational modifiers</li> <li>Affect Dimensions \u2014 model experiential response</li> <li>Practice Types \u2014 classify emergent patterns</li> </ol>"},{"location":"api_reference/#chora.core.types--design-rationale","title":"Design Rationale","text":"<p>Types are defined as string-backed enums to ensure: - Serialization compatibility across backends - Human-readable graph inspection - Extension without breaking existing data</p>"},{"location":"api_reference/#chora.core.types--examples","title":"Examples","text":"<p>from chora.core.types import NodeType, EpistemicLevel NodeType.ENCOUNTER  EpistemicLevel.OBSERVED.value 'observed'"},{"location":"api_reference/#chora.core.types.NodeType","title":"<code>NodeType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Classification of node types in the platial graph.</p> <p>Each type represents a distinct ontological category in platial modelling. Place is notably absent because it emerges as a subgraph, not a primitive.</p>"},{"location":"api_reference/#chora.core.types.NodeType--attributes","title":"Attributes","text":"<p>AGENT : str     An entity with situated experience (human, group, or proxy). SPATIAL_EXTENT : str     A weakly semanticised spatial support (geometry with minimal semantics). ENCOUNTER : str     A spatio-temporal relation between an agent and a spatial extent. CONTEXT : str     Situational modifiers that affect the character of an encounter. PRACTICE : str     An emergent, patterned structure over repeated encounters. AFFECT : str     An experiential response distribution attached to an encounter or place. FAMILIARITY : str     An evolving state variable representing accumulated experience. LIMINALITY : str     A conditional, transitional quality at spatial or experiential boundaries. MEANING : str     A structured symbolic interpretation attached to place.</p>"},{"location":"api_reference/#chora.core.types.NodeType--examples","title":"Examples","text":"<p>NodeType.ENCOUNTER  NodeType.ENCOUNTER.value 'encounter' NodeType('encounter')"},{"location":"api_reference/#chora.core.types.EdgeType","title":"<code>EdgeType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Classification of edge types in the platial graph.</p> <p>Edges encode relations, transitions, derivations, and interpretations. Platial qualities are primarily encoded on edges, not nodes.</p>"},{"location":"api_reference/#chora.core.types.EdgeType--attributes","title":"Attributes","text":"<p>PARTICIPATES_IN : str     Agent \u2500participates_in\u2500\u25b6 Encounter OCCURS_AT : str     Encounter \u2500occurs_at\u2500\u25b6 SpatialExtent HAS_CONTEXT : str     Encounter \u2500has_context\u2500\u25b6 Context DERIVES_FROM : str     Derived entity \u2500derives_from\u2500\u25b6 Source entity (provenance) TRANSITIONS_TO : str     Encounter \u2500transitions_to\u2500\u25b6 Encounter (temporal sequence) REINFORCES : str     Encounter \u2500reinforces\u2500\u25b6 Familiarity (strengthening relation) DECAYS : str     Time \u2500decays\u2500\u25b6 Familiarity (weakening relation) EXPRESSES : str     Encounter \u2500expresses\u2500\u25b6 Affect INTERPRETS_AS : str     Agent \u2500interprets_as\u2500\u25b6 Meaning (subjective interpretation) BELONGS_TO : str     Encounter \u2500belongs_to\u2500\u25b6 Practice (pattern membership) BOUNDS : str     SpatialExtent \u2500bounds\u2500\u25b6 Liminality (boundary relation) CROSSES : str     Encounter \u2500crosses\u2500\u25b6 Liminality (threshold crossing) SIMILAR_TO : str     Entity \u2500similar_to\u2500\u25b6 Entity (similarity relation) CONFLICTS_WITH : str     Meaning \u2500conflicts_with\u2500\u25b6 Meaning (interpretive conflict)</p>"},{"location":"api_reference/#chora.core.types.EdgeType--examples","title":"Examples","text":"<p>EdgeType.PARTICIPATES_IN"},{"location":"api_reference/#chora.core.types.EpistemicLevel","title":"<code>EpistemicLevel</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Classification of data by epistemic status.</p> <p>This is a core design principle: observed, derived, and interpreted data are explicitly distinguished throughout the library.</p>"},{"location":"api_reference/#chora.core.types.EpistemicLevel--attributes","title":"Attributes","text":"<p>OBSERVED : str     Direct observation or measurement from sensors, surveys, or traces.     Highest confidence, lowest interpretation. DERIVED : str     Computed from observed data using deterministic or probabilistic     methods. Provenance to source data is preserved. INTERPRETED : str     Semantic or symbolic interpretation involving subjective judgement.     Lowest confidence, highest interpretation.</p>"},{"location":"api_reference/#chora.core.types.EpistemicLevel--examples","title":"Examples","text":"<p>from chora.core.types import EpistemicLevel level = EpistemicLevel.OBSERVED level.is_more_certain_than(EpistemicLevel.DERIVED) True</p>"},{"location":"api_reference/#chora.core.types.EpistemicLevel--notes","title":"Notes","text":"<p>The ordering OBSERVED &gt; DERIVED &gt; INTERPRETED represents decreasing epistemic certainty and increasing interpretive content.</p>"},{"location":"api_reference/#chora.core.types.EpistemicLevel.certainty_order","title":"<code>certainty_order</code>  <code>property</code>","text":"<p>Return numeric ordering for certainty comparisons.</p>"},{"location":"api_reference/#chora.core.types.EpistemicLevel.is_more_certain_than","title":"<code>is_more_certain_than(other)</code>","text":"<p>Compare epistemic certainty levels.</p>"},{"location":"api_reference/#chora.core.types.EpistemicLevel.is_more_certain_than--parameters","title":"Parameters","text":"<p>other : EpistemicLevel     The level to compare against.</p>"},{"location":"api_reference/#chora.core.types.EpistemicLevel.is_more_certain_than--returns","title":"Returns","text":"<p>bool     True if this level is epistemically more certain.</p>"},{"location":"api_reference/#chora.core.types.EpistemicLevel.is_more_certain_than--examples","title":"Examples","text":"<p>EpistemicLevel.OBSERVED.is_more_certain_than(EpistemicLevel.DERIVED) True EpistemicLevel.INTERPRETED.is_more_certain_than(EpistemicLevel.OBSERVED) False</p>"},{"location":"api_reference/#chora.core.types.PracticeType","title":"<code>PracticeType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Classification of emergent practices over encounters.</p> <p>Practices are patterned structures that emerge from repeated encounters and form the basis of routines and habits.</p>"},{"location":"api_reference/#chora.core.types.PracticeType--attributes","title":"Attributes","text":"<p>ROUTINE : str     Regularly repeated pattern with consistent timing. HABIT : str     Automatic, often unconscious repeated behaviour. RITUAL : str     Symbolically meaningful repeated practice. EXPLORATION : str     Pattern of novelty-seeking and discovery. AVOIDANCE : str     Consistent pattern of avoiding certain places. DWELLING : str     Extended presence in a place. TRAVERSAL : str     Movement through places without dwelling.</p>"},{"location":"api_reference/#chora.core.types.PracticeType--examples","title":"Examples","text":"<p>PracticeType.ROUTINE"},{"location":"api_reference/#spatial-extent","title":"Spatial Extent","text":""},{"location":"api_reference/#chora.core.spatial_extent","title":"<code>chora.core.spatial_extent</code>","text":"<p>SpatialExtent Domain Object</p> <p>A SpatialExtent is a weakly semanticised spatial support \u2014 geometry with minimal semantics, allowing platial meaning to emerge from encounters.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent","title":"<code>SpatialExtent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlatialNode</code></p> <p>A weakly semanticised spatial support.</p> <p>SpatialExtent represents the spatial dimension of place without imposing strong semantic categories. Place meaning emerges through encounters rather than being predefined.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent--parameters","title":"Parameters","text":"<p>name : str     Human-readable name (optional, minimal semantics). geometry : BaseGeometry | None     Shapely geometry representing the spatial extent. extent_type : str     Loose classification (e.g., \"area\", \"path\", \"point\"). semantic_hints : dict[str, Any]     Optional weak semantic hints (not definitive categories).</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent--examples","title":"Examples","text":"<p>from shapely.geometry import Point, Polygon</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent--a-location-point","title":"A location point","text":"<p>cafe = SpatialExtent( ...     name=\"Corner Cafe\", ...     geometry=Point(-0.1276, 51.5074), ...     extent_type=\"point\" ... )</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent--an-area-polygon","title":"An area polygon","text":"<p>park = SpatialExtent( ...     name=\"Hyde Park\", ...     geometry=Polygon([...]), ...     extent_type=\"area\", ...     semantic_hints={\"land_use\": \"recreation\"} ... )</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.area_m2","title":"<code>area_m2</code>  <code>property</code>","text":"<p>Get area in square meters (approximate for geographic coords).</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.bounds","title":"<code>bounds</code>  <code>property</code>","text":"<p>Get bounding box (minx, miny, maxx, maxy).</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.centroid","title":"<code>centroid</code>  <code>property</code>","text":"<p>Get the centroid coordinates (lon, lat).</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.has_geometry","title":"<code>has_geometry</code>  <code>property</code>","text":"<p>Check if geometry is defined.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.buffer","title":"<code>buffer(distance)</code>","text":"<p>Create a new extent buffered by the given distance.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.contains_point","title":"<code>contains_point(lon, lat)</code>","text":"<p>Check if a point is within this extent.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.distance_to","title":"<code>distance_to(other)</code>","text":"<p>Calculate distance to another extent (in geometry units).</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.from_bounds","title":"<code>from_bounds(minx, miny, maxx, maxy, name='')</code>  <code>classmethod</code>","text":"<p>Create an extent from bounding box.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.from_geojson","title":"<code>from_geojson(geojson)</code>  <code>classmethod</code>","text":"<p>Create from GeoJSON feature.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.from_point","title":"<code>from_point(lon, lat, name='')</code>  <code>classmethod</code>","text":"<p>Create a point extent. Alias for point() method.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.get_hint","title":"<code>get_hint(key, default=None)</code>","text":"<p>Get a semantic hint.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.intersects","title":"<code>intersects(other)</code>","text":"<p>Check if this extent intersects another.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.point","title":"<code>point(lon, lat, name='')</code>  <code>classmethod</code>","text":"<p>Create a point extent.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.set_hint","title":"<code>set_hint(key, value)</code>","text":"<p>Set a semantic hint.</p>"},{"location":"api_reference/#chora.core.spatial_extent.SpatialExtent.to_geojson","title":"<code>to_geojson()</code>","text":"<p>Export geometry as GeoJSON.</p>"},{"location":"api_reference/#agent","title":"Agent","text":""},{"location":"api_reference/#chora.core.agent","title":"<code>chora.core.agent</code>","text":"<p>Agent Domain Object</p> <p>An Agent is an entity with situated experience \u2014 a human, group, or proxy that can participate in encounters with spatial extents.</p>"},{"location":"api_reference/#chora.core.agent.Agent","title":"<code>Agent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PlatialNode</code></p> <p>An entity with situated experience.</p> <p>Agents are the experiential subjects in platial modelling. They participate in encounters, develop familiarity, express affect, and interpret meaning.</p>"},{"location":"api_reference/#chora.core.agent.Agent--parameters","title":"Parameters","text":"<p>name : str     Human-readable name for this agent. agent_id : AgentId | None     Optional domain-specific identifier. agent_type : str     Type of agent (e.g., \"individual\", \"group\", \"proxy\"). attributes : dict[str, Any]     Agent attributes (demographics, preferences, etc.).</p>"},{"location":"api_reference/#chora.core.agent.Agent--examples","title":"Examples","text":"<p>alice = Agent(name=\"Alice\", agent_type=\"individual\") alice.node_type"},{"location":"api_reference/#chora.core.agent.Agent--with-custom-attributes","title":"With custom attributes","text":"<p>walker = Agent( ...     name=\"Walker 001\", ...     agent_type=\"individual\", ...     attributes={\"mobility\": \"walking\", \"age_group\": \"adult\"} ... )</p>"},{"location":"api_reference/#chora.core.agent.Agent.display_name","title":"<code>display_name</code>  <code>property</code>","text":"<p>Return display name, falling back to ID if no name.</p>"},{"location":"api_reference/#chora.core.agent.Agent.get_attribute","title":"<code>get_attribute(key, default=None)</code>","text":"<p>Get an agent attribute.</p>"},{"location":"api_reference/#chora.core.agent.Agent.group","title":"<code>group(name, members=None, **attributes)</code>  <code>classmethod</code>","text":"<p>Create a group agent.</p>"},{"location":"api_reference/#chora.core.agent.Agent.individual","title":"<code>individual(name, **attributes)</code>  <code>classmethod</code>","text":"<p>Create an individual agent.</p>"},{"location":"api_reference/#chora.core.agent.Agent.proxy","title":"<code>proxy(name, represented_by, **attributes)</code>  <code>classmethod</code>","text":"<p>Create a proxy agent (representing another entity).</p>"},{"location":"api_reference/#chora.core.agent.Agent.set_attribute","title":"<code>set_attribute(key, value)</code>","text":"<p>Set an agent attribute.</p>"},{"location":"api_reference/#temporal-functions","title":"Temporal Functions","text":""},{"location":"api_reference/#chora.core.temporal","title":"<code>chora.core.temporal</code>","text":"<p>Temporal Semantics for Chora</p> <p>This module implements temporal representation and functions for platial modelling. All nodes and edges have explicit lifetimes; decay and reinforcement functions govern familiarity, affect, and practice stability.</p>"},{"location":"api_reference/#chora.core.temporal.Temporal","title":"<code>Temporal</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for objects with temporal validity.</p>"},{"location":"api_reference/#chora.core.temporal.TemporalValidity","title":"<code>TemporalValidity</code>  <code>dataclass</code>","text":"<p>Tracks temporal validity with creation and modification timestamps.</p>"},{"location":"api_reference/#chora.core.temporal.TemporalValidity--attributes","title":"Attributes","text":"<p>created_at : Timestamp     When this entity was created. valid_from : Timestamp | None     Start of validity period. valid_to : Timestamp | None     End of validity period (None = still valid). modified_at : Timestamp | None     When this entity was last modified.</p>"},{"location":"api_reference/#chora.core.temporal.TemporalValidity.interval","title":"<code>interval</code>  <code>property</code>","text":"<p>Return the validity as a TimeInterval.</p>"},{"location":"api_reference/#chora.core.temporal.TemporalValidity.is_current","title":"<code>is_current</code>  <code>property</code>","text":"<p>Check if currently valid (valid_to is None or in future).</p>"},{"location":"api_reference/#chora.core.temporal.TemporalValidity.invalidate","title":"<code>invalidate(at=None)</code>","text":"<p>Mark as no longer valid.</p>"},{"location":"api_reference/#chora.core.temporal.TemporalValidity.is_valid_at","title":"<code>is_valid_at(timestamp)</code>","text":"<p>Check if valid at the given timestamp.</p>"},{"location":"api_reference/#chora.core.temporal.TimeInterval","title":"<code>TimeInterval</code>  <code>dataclass</code>","text":"<p>Represents a time interval with optional open bounds.</p> <p>A time interval [start, end] where either bound may be None (open-ended). Supports containment, overlap, and duration queries.</p>"},{"location":"api_reference/#chora.core.temporal.TimeInterval--parameters","title":"Parameters","text":"<p>start : Timestamp | None     Start of interval (inclusive). None means unbounded past. end : Timestamp | None     End of interval (inclusive). None means unbounded future.</p>"},{"location":"api_reference/#chora.core.temporal.TimeInterval--examples","title":"Examples","text":"<p>from datetime import datetime interval = TimeInterval( ...     start=datetime(2024, 1, 1), ...     end=datetime(2024, 12, 31) ... ) interval.contains(datetime(2024, 6, 15)) True interval.duration datetime.timedelta(days=365)</p>"},{"location":"api_reference/#chora.core.temporal.TimeInterval.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Return the duration of this interval, or None if unbounded.</p>"},{"location":"api_reference/#chora.core.temporal.TimeInterval.is_bounded","title":"<code>is_bounded</code>  <code>property</code>","text":"<p>Check if both bounds are defined.</p>"},{"location":"api_reference/#chora.core.temporal.TimeInterval.is_instant","title":"<code>is_instant</code>  <code>property</code>","text":"<p>Check if this represents a single point in time.</p>"},{"location":"api_reference/#chora.core.temporal.TimeInterval.contains","title":"<code>contains(timestamp)</code>","text":"<p>Check if timestamp falls within this interval.</p>"},{"location":"api_reference/#chora.core.temporal.TimeInterval.from_now","title":"<code>from_now(duration)</code>  <code>classmethod</code>","text":"<p>Create an interval from now for the given duration.</p>"},{"location":"api_reference/#chora.core.temporal.TimeInterval.instant","title":"<code>instant(timestamp)</code>  <code>classmethod</code>","text":"<p>Create an interval representing a single instant.</p>"},{"location":"api_reference/#chora.core.temporal.TimeInterval.overlaps","title":"<code>overlaps(other)</code>","text":"<p>Check if this interval overlaps with another.</p>"},{"location":"api_reference/#chora.core.temporal.TimeInterval.unbounded","title":"<code>unbounded()</code>  <code>classmethod</code>","text":"<p>Create an unbounded interval (all time).</p>"},{"location":"api_reference/#chora.core.temporal.compute_decay","title":"<code>compute_decay(initial_value, start, end, decay_fn=exponential_decay)</code>","text":"<p>Compute decayed value between two timestamps.</p>"},{"location":"api_reference/#chora.core.temporal.compute_decay--parameters","title":"Parameters","text":"<p>initial_value : float     Value at start time. start : Timestamp     Starting timestamp. end : Timestamp     Ending timestamp. decay_fn : DecayFunction     Decay function to apply.</p>"},{"location":"api_reference/#chora.core.temporal.compute_decay--returns","title":"Returns","text":"<p>float     Decayed value at end time.</p>"},{"location":"api_reference/#chora.core.temporal.exponential_decay","title":"<code>exponential_decay(initial_value, time_delta, half_life=7.0)</code>","text":"<p>Exponential decay function for familiarity and affect.</p>"},{"location":"api_reference/#chora.core.temporal.exponential_decay--parameters","title":"Parameters","text":"<p>initial_value : float     Starting value (typically in [0, 1]). time_delta : float     Time elapsed (in days). half_life : float     Time for value to decay to half (in days). Default 7 days.</p>"},{"location":"api_reference/#chora.core.temporal.exponential_decay--returns","title":"Returns","text":"<p>float     Decayed value.</p>"},{"location":"api_reference/#chora.core.temporal.exponential_decay--examples","title":"Examples","text":"<p>exponential_decay(1.0, 7.0, half_life=7.0)  # After one half-life 0.5 exponential_decay(1.0, 14.0, half_life=7.0)  # After two half-lives 0.25</p>"},{"location":"api_reference/#chora.core.temporal.linear_decay","title":"<code>linear_decay(initial_value, time_delta, rate=0.1)</code>","text":"<p>Linear decay function.</p>"},{"location":"api_reference/#chora.core.temporal.linear_decay--parameters","title":"Parameters","text":"<p>initial_value : float     Starting value. time_delta : float     Time elapsed (in days). rate : float     Decay rate per day. Default 0.1.</p>"},{"location":"api_reference/#chora.core.temporal.linear_decay--returns","title":"Returns","text":"<p>float     Decayed value, clamped to [0, initial_value].</p>"},{"location":"api_reference/#chora.core.temporal.linear_reinforcement","title":"<code>linear_reinforcement(current_value, increment=0.1, maximum=1.0)</code>","text":"<p>Linear reinforcement with saturation.</p>"},{"location":"api_reference/#chora.core.temporal.linear_reinforcement--parameters","title":"Parameters","text":"<p>current_value : float     Current value before reinforcement. increment : float     Amount to add. Default 0.1. maximum : float     Maximum allowed value. Default 1.0.</p>"},{"location":"api_reference/#chora.core.temporal.linear_reinforcement--returns","title":"Returns","text":"<p>float     Reinforced value, clamped to maximum.</p>"},{"location":"api_reference/#chora.core.temporal.power_law_decay","title":"<code>power_law_decay(initial_value, time_delta, exponent=0.5, offset=1.0)</code>","text":"<p>Power law decay: value = initial / (offset + time)^exponent</p> <p>Models slower decay over time, often observed in memory research.</p>"},{"location":"api_reference/#chora.core.temporal.power_law_decay--parameters","title":"Parameters","text":"<p>initial_value : float     Starting value. time_delta : float     Time elapsed (in days). exponent : float     Power law exponent. Default 0.5. offset : float     Time offset to avoid division by zero. Default 1.0.</p>"},{"location":"api_reference/#chora.core.temporal.power_law_decay--returns","title":"Returns","text":"<p>float     Decayed value.</p>"},{"location":"api_reference/#chora.core.temporal.saturating_reinforcement","title":"<code>saturating_reinforcement(current_value, increment=0.1, maximum=1.0)</code>","text":"<p>Saturating reinforcement: diminishing returns near maximum.</p> <p>Uses formula: new = current + increment * (1 - current/maximum)</p>"},{"location":"api_reference/#chora.core.temporal.saturating_reinforcement--parameters","title":"Parameters","text":"<p>current_value : float     Current value before reinforcement. increment : float     Base increment amount. Default 0.1. maximum : float     Asymptotic maximum. Default 1.0.</p>"},{"location":"api_reference/#chora.core.temporal.saturating_reinforcement--returns","title":"Returns","text":"<p>float     Reinforced value approaching but never exceeding maximum.</p>"},{"location":"api_reference/#uncertainty","title":"Uncertainty","text":""},{"location":"api_reference/#chora.core.uncertainty","title":"<code>chora.core.uncertainty</code>","text":"<p>Uncertainty Representation for Chora</p> <p>This module provides probabilistic and fuzzy representation of uncertainty. Vagueness is modelled, not suppressed. This is a core design principle.</p>"},{"location":"api_reference/#chora.core.uncertainty.CategoricalDistribution","title":"<code>CategoricalDistribution</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ProbabilityDistribution</code></p> <p>Categorical distribution over discrete outcomes.</p>"},{"location":"api_reference/#chora.core.uncertainty.CategoricalDistribution--parameters","title":"Parameters","text":"<p>categories : Sequence[str]     Category labels. probabilities : Sequence[float]     Probability for each category (must sum to 1).</p>"},{"location":"api_reference/#chora.core.uncertainty.CategoricalDistribution.entropy","title":"<code>entropy</code>  <code>property</code>","text":"<p>Shannon entropy of the distribution.</p>"},{"location":"api_reference/#chora.core.uncertainty.CategoricalDistribution.mode","title":"<code>mode</code>  <code>property</code>","text":"<p>Return the most likely category.</p>"},{"location":"api_reference/#chora.core.uncertainty.CategoricalDistribution.pdf","title":"<code>pdf(x)</code>","text":"<p>Not applicable for categorical; raises error.</p>"},{"location":"api_reference/#chora.core.uncertainty.CategoricalDistribution.probability","title":"<code>probability(category)</code>","text":"<p>Get probability of a specific category.</p>"},{"location":"api_reference/#chora.core.uncertainty.CategoricalDistribution.sample","title":"<code>sample()</code>","text":"<p>Draw a random category.</p>"},{"location":"api_reference/#chora.core.uncertainty.ConfidenceInterval","title":"<code>ConfidenceInterval</code>  <code>dataclass</code>","text":"<p>Represents a confidence interval.</p>"},{"location":"api_reference/#chora.core.uncertainty.ConfidenceInterval--parameters","title":"Parameters","text":"<p>lower : float     Lower bound of the interval. upper : float     Upper bound of the interval. confidence : float     Confidence level (e.g., 0.95 for 95%).</p>"},{"location":"api_reference/#chora.core.uncertainty.ConfidenceInterval.midpoint","title":"<code>midpoint</code>  <code>property</code>","text":"<p>Return the midpoint of the interval.</p>"},{"location":"api_reference/#chora.core.uncertainty.ConfidenceInterval.width","title":"<code>width</code>  <code>property</code>","text":"<p>Return the width of the interval.</p>"},{"location":"api_reference/#chora.core.uncertainty.ConfidenceInterval.contains","title":"<code>contains(value)</code>","text":"<p>Check if a value falls within the interval.</p>"},{"location":"api_reference/#chora.core.uncertainty.FuzzyMembership","title":"<code>FuzzyMembership</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for fuzzy membership functions.</p>"},{"location":"api_reference/#chora.core.uncertainty.FuzzyMembership.membership","title":"<code>membership(x)</code>  <code>abstractmethod</code>","text":"<p>Return membership degree in [0, 1] for value x.</p>"},{"location":"api_reference/#chora.core.uncertainty.GaussianDistribution","title":"<code>GaussianDistribution</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ProbabilityDistribution</code></p> <p>Gaussian (normal) distribution.</p>"},{"location":"api_reference/#chora.core.uncertainty.GaussianDistribution--parameters","title":"Parameters","text":"<p>mu : float     Mean of the distribution. sigma : float     Standard deviation (must be positive).</p>"},{"location":"api_reference/#chora.core.uncertainty.GaussianDistribution.confidence_interval","title":"<code>confidence_interval(confidence=0.95)</code>","text":"<p>Return confidence interval for given level.</p>"},{"location":"api_reference/#chora.core.uncertainty.GaussianDistribution.pdf","title":"<code>pdf(x)</code>","text":"<p>Probability density at x.</p>"},{"location":"api_reference/#chora.core.uncertainty.GaussianDistribution.sample","title":"<code>sample()</code>","text":"<p>Draw a random sample using Box-Muller transform.</p>"},{"location":"api_reference/#chora.core.uncertainty.ProbabilityDistribution","title":"<code>ProbabilityDistribution</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for probability distributions.</p>"},{"location":"api_reference/#chora.core.uncertainty.ProbabilityDistribution.mean","title":"<code>mean</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Expected value.</p>"},{"location":"api_reference/#chora.core.uncertainty.ProbabilityDistribution.variance","title":"<code>variance</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Variance.</p>"},{"location":"api_reference/#chora.core.uncertainty.ProbabilityDistribution.pdf","title":"<code>pdf(x)</code>  <code>abstractmethod</code>","text":"<p>Probability density function.</p>"},{"location":"api_reference/#chora.core.uncertainty.ProbabilityDistribution.sample","title":"<code>sample()</code>  <code>abstractmethod</code>","text":"<p>Draw a random sample from the distribution.</p>"},{"location":"api_reference/#chora.core.uncertainty.TrapezoidalFuzzy","title":"<code>TrapezoidalFuzzy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FuzzyMembership</code></p> <p>Trapezoidal fuzzy membership function.</p>"},{"location":"api_reference/#chora.core.uncertainty.TrapezoidalFuzzy--parameters","title":"Parameters","text":"<p>left_foot : float     Left foot (membership = 0). left_shoulder : float     Start of flat top (membership = 1). right_shoulder : float     End of flat top (membership = 1). right_foot : float     Right foot (membership = 0).</p>"},{"location":"api_reference/#chora.core.uncertainty.TriangularFuzzy","title":"<code>TriangularFuzzy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FuzzyMembership</code></p> <p>Triangular fuzzy membership function.</p>"},{"location":"api_reference/#chora.core.uncertainty.TriangularFuzzy--parameters","title":"Parameters","text":"<p>left : float     Left foot (membership = 0). peak : float     Peak (membership = 1). right : float     Right foot (membership = 0).</p>"},{"location":"api_reference/#chora.core.uncertainty.UncertaintyValue","title":"<code>UncertaintyValue</code>  <code>dataclass</code>","text":"<p>A value with associated uncertainty.</p>"},{"location":"api_reference/#chora.core.uncertainty.UncertaintyValue--parameters","title":"Parameters","text":"<p>value : float     Central/expected value. uncertainty : float     Uncertainty measure (interpretation depends on context). confidence : float | None     Optional confidence level.</p>"},{"location":"api_reference/#chora.core.uncertainty.UncertaintyValue--examples","title":"Examples","text":"<p>uv = UncertaintyValue(value=0.75, uncertainty=0.1) uv.as_interval(confidence=0.95) ConfidenceInterval(lower=0.55, upper=0.95, confidence=0.95)</p>"},{"location":"api_reference/#chora.core.uncertainty.UncertaintyValue.as_interval","title":"<code>as_interval(confidence=0.95)</code>","text":"<p>Convert to confidence interval (assuming \u00b1uncertainty).</p>"},{"location":"api_reference/#derivation-module","title":"Derivation Module","text":""},{"location":"api_reference/#chora.derive","title":"<code>chora.derive</code>","text":"<p>Chora Derive Module</p> <p>Theory-encoded derivation operators for transforming raw data into platial structures. These operators embody platial theory, not ad-hoc heuristics.</p> <p>Operators include: - Encounter extraction from traces - Familiarity update functions - Practice detection via sequence analysis - Liminality inference from transitions - Affect and meaning attachment with provenance - Place emergence as subgraph extraction</p>"},{"location":"api_reference/#chora.derive.attach_affect","title":"<code>attach_affect(encounter, valence, arousal, source='external', uncertainty=0.1)</code>","text":"<p>Attach affect to an encounter with explicit values.</p>"},{"location":"api_reference/#chora.derive.attach_affect--parameters","title":"Parameters","text":"<p>encounter : Encounter     The encounter to attach affect to. valence : float     Valence value [-1, 1]. arousal : float     Arousal value [0, 1]. source : str     Source of affect data (\"self_report\", \"derived\", \"external\"). uncertainty : float     Uncertainty in the affect values.</p>"},{"location":"api_reference/#chora.derive.attach_affect--returns","title":"Returns","text":"<p>Affect     The created affect node.</p>"},{"location":"api_reference/#chora.derive.attach_meaning","title":"<code>attach_meaning(agent_id, extent_id, content, meaning_type=MeaningType.PERSONAL, symbols=None, strength=1.0)</code>","text":"<p>Attach meaning to a place.</p>"},{"location":"api_reference/#chora.derive.attach_meaning--parameters","title":"Parameters","text":"<p>agent_id : AgentId | None     Who holds this meaning (None for shared). extent_id : ExtentId     Which place. content : str     The meaning content. meaning_type : MeaningType     Type of meaning. symbols : Sequence[str] | None     Symbolic labels. strength : float     How strongly held [0, 1].</p>"},{"location":"api_reference/#chora.derive.attach_meaning--returns","title":"Returns","text":"<p>Meaning     The created meaning node.</p>"},{"location":"api_reference/#chora.derive.compute_familiarity_trajectory","title":"<code>compute_familiarity_trajectory(encounters, agent_id, extent_id, decay_half_life_days=14.0)</code>","text":"<p>Compute familiarity trajectory over time.</p> <p>Returns a time series of (timestamp, familiarity_value) pairs showing how familiarity evolved through the encounters.</p>"},{"location":"api_reference/#chora.derive.compute_familiarity_trajectory--parameters","title":"Parameters","text":"<p>encounters : Sequence[Encounter]     Encounters for this agent-extent pair. agent_id : AgentId     Agent ID. extent_id : ExtentId     Extent ID. decay_half_life_days : float     Half-life for familiarity decay.</p>"},{"location":"api_reference/#chora.derive.compute_familiarity_trajectory--returns","title":"Returns","text":"<p>list[tuple[datetime, float]]     Time series of familiarity values.</p>"},{"location":"api_reference/#chora.derive.decay_all_familiarities","title":"<code>decay_all_familiarities(graph, to_time=None)</code>","text":"<p>Apply decay to all familiarity nodes in the graph.</p> <p>Returns the number of familiarities updated.</p>"},{"location":"api_reference/#chora.derive.derive_affect_from_context","title":"<code>derive_affect_from_context(encounter, contexts)</code>","text":"<p>Derive affect from encounter context.</p> <p>Uses contextual information to infer likely affect. This is a theory-encoded heuristic based on environmental psychology.</p>"},{"location":"api_reference/#chora.derive.derive_affect_from_context--parameters","title":"Parameters","text":"<p>encounter : Encounter     The encounter. contexts : list[Context]     Associated contexts.</p>"},{"location":"api_reference/#chora.derive.derive_affect_from_context--returns","title":"Returns","text":"<p>Affect | None     Derived affect, or None if insufficient context.</p>"},{"location":"api_reference/#chora.derive.derive_meaning_from_practices","title":"<code>derive_meaning_from_practices(practices, agent_id, extent_id)</code>","text":"<p>Derive meaning from observed practices.</p> <p>Practices reveal how a place is used and experienced, which gives rise to functional and personal meanings.</p>"},{"location":"api_reference/#chora.derive.derive_meaning_from_practices--parameters","title":"Parameters","text":"<p>practices : Sequence[Practice]     Practices involving this place. agent_id : AgentId     Agent whose practices to analyze. extent_id : ExtentId     The place to derive meaning for.</p>"},{"location":"api_reference/#chora.derive.derive_meaning_from_practices--returns","title":"Returns","text":"<p>list[Meaning]     Derived meanings.</p>"},{"location":"api_reference/#chora.derive.detect_boundary_crossings","title":"<code>detect_boundary_crossings(encounters, extents)</code>","text":"<p>Detect boundary crossings between adjacent encounters.</p> <p>Returns list of (boundary_extent_id, from_type, to_type) tuples.</p>"},{"location":"api_reference/#chora.derive.detect_practices","title":"<code>detect_practices(encounters, agent_id, config=None)</code>","text":"<p>Detect practices from encounter sequences.</p> <p>Identifies routines, habits, and other patterns based on spatial, temporal, and sequential regularities.</p>"},{"location":"api_reference/#chora.derive.detect_practices--parameters","title":"Parameters","text":"<p>encounters : Sequence[Encounter]     Encounters to analyze. agent_id : AgentId     Agent to detect practices for. config : PracticeDetectionConfig | None     Detection configuration.</p>"},{"location":"api_reference/#chora.derive.detect_practices--returns","title":"Returns","text":"<p>list[Practice]     Detected practices.</p>"},{"location":"api_reference/#chora.derive.detect_routines","title":"<code>detect_routines(encounters, config=None)</code>","text":"<p>Detect location-time routines.</p> <p>A routine is a repeated pattern of visiting the same location at similar times.</p>"},{"location":"api_reference/#chora.derive.extract_encounters","title":"<code>extract_encounters(trace, agent_id, extents, config=None)</code>","text":"<p>Extract encounters from a location trace.</p> <p>An encounter is detected when the agent dwells within a spatial extent for a minimum duration.</p>"},{"location":"api_reference/#chora.derive.extract_encounters--parameters","title":"Parameters","text":"<p>trace : Sequence[TracePoint]     Ordered sequence of location points. agent_id : AgentId     ID of the agent being tracked. extents : Sequence[SpatialExtent]     Spatial extents to match against. config : EncounterExtractionConfig | None     Extraction configuration.</p>"},{"location":"api_reference/#chora.derive.extract_encounters--returns","title":"Returns","text":"<p>list[Encounter]     Extracted encounters.</p>"},{"location":"api_reference/#chora.derive.extract_encounters--examples","title":"Examples","text":"<p>trace = [ ...     TracePoint(datetime(2024, 1, 1, 10, 0), -0.127, 51.507), ...     TracePoint(datetime(2024, 1, 1, 10, 30), -0.127, 51.507), ...     TracePoint(datetime(2024, 1, 1, 11, 0), -0.128, 51.508), ... ] park = SpatialExtent.from_bounds(-0.13, 51.50, -0.12, 51.51, \"Park\") encounters = extract_encounters(trace, AgentId(\"a1\"), [park])</p>"},{"location":"api_reference/#chora.derive.extract_encounters_from_trace","title":"<code>extract_encounters_from_trace(trace, agent_id, config=None)</code>","text":"<p>Extract encounters by clustering a trace without predefined extents.</p> <p>Detects dwell locations by finding spatial clusters of points that exceed the minimum duration threshold.</p>"},{"location":"api_reference/#chora.derive.extract_place","title":"<code>extract_place(graph, extent_id, agent_id=None)</code>","text":"<p>Extract an emergent place centered on a spatial extent.</p> <p>Gathers all encounters, affects, meanings, and familiarities related to the specified extent, optionally filtered by agent.</p>"},{"location":"api_reference/#chora.derive.extract_place--parameters","title":"Parameters","text":"<p>graph : PlatialGraph     The platial graph. extent_id : ExtentId     ID of the central spatial extent. agent_id : AgentId | None     Optional agent filter.</p>"},{"location":"api_reference/#chora.derive.extract_place--returns","title":"Returns","text":"<p>EmergentPlace     The emergent place structure.</p>"},{"location":"api_reference/#chora.derive.find_emergent_places","title":"<code>find_emergent_places(graph, agent_id=None, min_encounters=3)</code>","text":"<p>Find all emergent places in the graph.</p> <p>Returns places that have sufficient activity to be meaningful.</p>"},{"location":"api_reference/#chora.derive.find_sequence_patterns","title":"<code>find_sequence_patterns(encounters, config=None)</code>","text":"<p>Find sequential patterns (A \u2192 B \u2192 C).</p> <p>Returns list of (pattern_name, encounter_ids, regularity).</p>"},{"location":"api_reference/#chora.derive.infer_liminality","title":"<code>infer_liminality(encounters, extents, config=None)</code>","text":"<p>Infer liminal zones from transition patterns.</p> <p>Identifies spatial extents that frequently serve as transition points between other places.</p>"},{"location":"api_reference/#chora.derive.infer_liminality--parameters","title":"Parameters","text":"<p>encounters : Sequence[Encounter]     Ordered encounters. extents : dict[str, SpatialExtent]     Mapping of extent IDs to SpatialExtent objects. config : LiminalityInferenceConfig | None     Inference configuration.</p>"},{"location":"api_reference/#chora.derive.infer_liminality--returns","title":"Returns","text":"<p>list[Liminality]     Inferred liminal zones.</p>"},{"location":"api_reference/#chora.derive.merge_nearby_encounters","title":"<code>merge_nearby_encounters(encounters, max_time_gap=timedelta(minutes=5))</code>","text":"<p>Merge temporally adjacent encounters at the same extent.</p>"},{"location":"api_reference/#chora.derive.update_familiarity","title":"<code>update_familiarity(graph, encounter)</code>","text":"<p>Update familiarity based on a new encounter.</p> <p>Finds or creates a Familiarity node for the agent-extent pair and reinforces it based on the encounter.</p>"},{"location":"api_reference/#chora.derive.update_familiarity--parameters","title":"Parameters","text":"<p>graph : PlatialGraph     The platial graph. encounter : Encounter     The encounter to process.</p>"},{"location":"api_reference/#chora.derive.update_familiarity--returns","title":"Returns","text":"<p>Familiarity     The updated familiarity node.</p>"},{"location":"api_reference/#query-module","title":"Query Module","text":""},{"location":"api_reference/#chora.query","title":"<code>chora.query</code>","text":"<p>Chora Query Module</p> <p>High-level platial queries and graph traversal operations. Queries compile down to graph traversals with temporal filtering.</p>"},{"location":"api_reference/#chora.query.PlatialQuery","title":"<code>PlatialQuery</code>  <code>dataclass</code>","text":"<p>Fluent query builder for platial queries.</p>"},{"location":"api_reference/#chora.query.PlatialQuery--examples","title":"Examples","text":"<p>query = (PlatialQuery(graph) ...     .for_agent(\"walker_001\") ...     .with_familiarity(min_value=0.5) ...     .with_positive_affect() ...     .valid_at(datetime.now())) places = query.execute()</p>"},{"location":"api_reference/#chora.query.PlatialQuery.add_filter","title":"<code>add_filter(predicate)</code>","text":"<p>Add custom filter.</p>"},{"location":"api_reference/#chora.query.PlatialQuery.at_extents","title":"<code>at_extents(extent_ids)</code>","text":"<p>Filter to specific extents.</p>"},{"location":"api_reference/#chora.query.PlatialQuery.execute","title":"<code>execute()</code>","text":"<p>Execute query and return matching places.</p>"},{"location":"api_reference/#chora.query.PlatialQuery.for_agent","title":"<code>for_agent(agent_id)</code>","text":"<p>Filter to a specific agent.</p>"},{"location":"api_reference/#chora.query.PlatialQuery.valid_at","title":"<code>valid_at(timestamp)</code>","text":"<p>Filter to nodes valid at timestamp.</p>"},{"location":"api_reference/#chora.query.PlatialQuery.with_familiarity","title":"<code>with_familiarity(min_value=None, max_value=None)</code>","text":"<p>Filter by familiarity range.</p>"},{"location":"api_reference/#chora.query.PlatialQuery.with_negative_affect","title":"<code>with_negative_affect()</code>","text":"<p>Filter to negative affect.</p>"},{"location":"api_reference/#chora.query.PlatialQuery.with_positive_affect","title":"<code>with_positive_affect()</code>","text":"<p>Filter to positive affect.</p>"},{"location":"api_reference/#chora.query.find_connected","title":"<code>find_connected(graph, node_id, edge_types=None)</code>","text":"<p>Find all nodes connected to the given node.</p>"},{"location":"api_reference/#chora.query.find_familiar_places","title":"<code>find_familiar_places(graph, agent_id, min_familiarity=0.5)</code>","text":"<p>Find places where agent has high familiarity.</p>"},{"location":"api_reference/#chora.query.find_path","title":"<code>find_path(graph, start_id, end_id, edge_types=None)</code>","text":"<p>Find shortest path between two nodes.</p> <p>Returns list of node IDs or None if no path exists.</p>"},{"location":"api_reference/#chora.query.find_positive_places","title":"<code>find_positive_places(graph, agent_id)</code>","text":"<p>Find places with positive affect for agent.</p>"},{"location":"api_reference/#chora.query.find_practices_like","title":"<code>find_practices_like(graph, template, min_similarity=0.5)</code>","text":"<p>Find practices similar to a template.</p>"},{"location":"api_reference/#chora.query.find_routine_places","title":"<code>find_routine_places(graph, agent_id, min_encounters=5)</code>","text":"<p>Find places that are part of routines.</p>"},{"location":"api_reference/#chora.query.match_pattern","title":"<code>match_pattern(graph, pattern_type, **kwargs)</code>","text":"<p>Match a named pattern against the graph.</p>"},{"location":"api_reference/#chora.query.place_similarity","title":"<code>place_similarity(p1, p2)</code>","text":"<p>Compute similarity between two emergent places.</p> <p>Considers familiarity, affect, and encounter patterns.</p>"},{"location":"api_reference/#chora.query.practice_similarity","title":"<code>practice_similarity(p1, p2)</code>","text":"<p>Compute similarity between two practices.</p>"},{"location":"api_reference/#chora.query.query_encounters","title":"<code>query_encounters(graph, agent_id=None, extent_id=None, start_time=None, end_time=None)</code>","text":"<p>Query encounters with filters.</p>"},{"location":"api_reference/#chora.query.snapshot_query","title":"<code>snapshot_query(graph, at)</code>","text":"<p>Get a snapshot of the graph at a specific time.</p> <p>Returns a new graph containing only nodes and edges valid at the given timestamp.</p>"},{"location":"api_reference/#chora.query.temporal_range_query","title":"<code>temporal_range_query(graph, start, end)</code>","text":"<p>Query nodes active during a time range.</p> <p>Yields nodes whose validity overlaps with [start, end].</p>"},{"location":"api_reference/#chora.query.traverse_from","title":"<code>traverse_from(graph, start_id, edge_types=None, max_depth=3)</code>","text":"<p>Breadth-first traversal from a starting node.</p> <p>Yields (node, depth) tuples.</p>"},{"location":"api_reference/#adapters","title":"Adapters","text":""},{"location":"api_reference/#base-adapter","title":"Base Adapter","text":""},{"location":"api_reference/#chora.adapters.base","title":"<code>chora.adapters.base</code>","text":"<p>Base Adapter Interface</p> <p>Abstract interface for graph storage backends.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter","title":"<code>GraphAdapter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for graph storage adapters.</p> <p>Adapters provide persistence and querying for platial graphs, abstracting over different backend technologies.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.add_edge","title":"<code>add_edge(edge)</code>  <code>abstractmethod</code>","text":"<p>Add or update a single edge.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.add_node","title":"<code>add_node(node)</code>  <code>abstractmethod</code>","text":"<p>Add or update a single node.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.connect","title":"<code>connect(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Establish connection to the backend.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.delete_edge","title":"<code>delete_edge(edge_id)</code>  <code>abstractmethod</code>","text":"<p>Delete an edge. Returns True if deleted.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.delete_node","title":"<code>delete_node(node_id)</code>  <code>abstractmethod</code>","text":"<p>Delete a node. Returns True if deleted.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.disconnect","title":"<code>disconnect()</code>  <code>abstractmethod</code>","text":"<p>Close connection to the backend.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.get_edge","title":"<code>get_edge(edge_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieve an edge by ID.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.get_node","title":"<code>get_node(node_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieve a node by ID.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.load_graph","title":"<code>load_graph(name)</code>  <code>abstractmethod</code>","text":"<p>Load a graph by name from the backend.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.query_edges","title":"<code>query_edges(edge_type=None, source_id=None, target_id=None, **filters)</code>  <code>abstractmethod</code>","text":"<p>Query edges with optional filters.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.query_nodes","title":"<code>query_nodes(node_type=None, **filters)</code>  <code>abstractmethod</code>","text":"<p>Query nodes with optional filters.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.save_graph","title":"<code>save_graph(graph)</code>  <code>abstractmethod</code>","text":"<p>Save entire graph to the backend.</p>"},{"location":"api_reference/#chora.adapters.base.GraphAdapter.snapshot","title":"<code>snapshot(at)</code>","text":"<p>Get temporal snapshot (default: load and filter).</p>"},{"location":"api_reference/#in-memory-adapter","title":"In-Memory Adapter","text":""},{"location":"api_reference/#chora.adapters.memory","title":"<code>chora.adapters.memory</code>","text":"<p>In-Memory Adapter</p> <p>Default adapter that stores graphs in memory. Suitable for development, testing, and small datasets.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter","title":"<code>InMemoryAdapter</code>","text":"<p>               Bases: <code>GraphAdapter</code></p> <p>In-memory graph storage adapter.</p> <p>Stores graphs in dictionaries. Supports multiple named graphs. Data is lost when the adapter is garbage collected.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter--examples","title":"Examples","text":"<p>adapter = InMemoryAdapter() adapter.connect() adapter.save_graph(my_graph) loaded = adapter.load_graph(\"my_graph\")</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.add_edge","title":"<code>add_edge(edge)</code>","text":"<p>Add edge to active graph.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.add_node","title":"<code>add_node(node)</code>","text":"<p>Add node to active graph.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.clear","title":"<code>clear()</code>","text":"<p>Clear all stored graphs.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.connect","title":"<code>connect(**kwargs)</code>","text":"<p>Connect (no-op for in-memory).</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.delete_edge","title":"<code>delete_edge(edge_id)</code>","text":"<p>Delete edge from active graph.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.delete_graph","title":"<code>delete_graph(name)</code>","text":"<p>Delete a graph. Returns True if deleted.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.delete_node","title":"<code>delete_node(node_id)</code>","text":"<p>Delete node from active graph.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect (no-op for in-memory).</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.get_edge","title":"<code>get_edge(edge_id)</code>","text":"<p>Get edge from active graph.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.get_node","title":"<code>get_node(node_id)</code>","text":"<p>Get node from active graph.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.list_graphs","title":"<code>list_graphs()</code>","text":"<p>List all stored graph names.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.load_graph","title":"<code>load_graph(name)</code>","text":"<p>Load graph from memory.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.query_edges","title":"<code>query_edges(edge_type=None, source_id=None, target_id=None, **filters)</code>","text":"<p>Query edges in active graph.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.query_nodes","title":"<code>query_nodes(node_type=None, **filters)</code>","text":"<p>Query nodes in active graph.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.save_graph","title":"<code>save_graph(graph)</code>","text":"<p>Save graph to memory.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.set_active_graph","title":"<code>set_active_graph(graph)</code>","text":"<p>Set the active graph for node/edge operations.</p>"},{"location":"api_reference/#chora.adapters.memory.InMemoryAdapter.snapshot","title":"<code>snapshot(at)</code>","text":"<p>Get temporal snapshot of active graph.</p>"},{"location":"api_reference/#cli","title":"CLI","text":""},{"location":"api_reference/#chora.cli","title":"<code>chora.cli</code>","text":"<p>Chora CLI \u2014 Command-line interface for the platial modelling library.</p> Usage <p>chora load gpx  --agent  chora load geojson  chora derive familiarity --agent  chora derive practices --agent  chora query familiar --agent  --min  chora viz export --format d3 --output"},{"location":"api_reference/#chora.cli.cli","title":"<code>cli()</code>","text":"<p>Chora \u2014 A platial modelling library for Python.</p> <p>Model human experience of place with encounters, familiarity, affect, and practices.</p>"},{"location":"api_reference/#chora.cli.derive","title":"<code>derive()</code>","text":"<p>Derive platial qualities from data.</p>"},{"location":"api_reference/#chora.cli.derive_familiarity","title":"<code>derive_familiarity(agent)</code>","text":"<p>Update familiarity scores for an agent.</p>"},{"location":"api_reference/#chora.cli.derive_practices","title":"<code>derive_practices(agent, min_occurrences)</code>","text":"<p>Detect practices and routines for an agent.</p>"},{"location":"api_reference/#chora.cli.export_d3","title":"<code>export_d3(graph)</code>","text":"<p>Export graph to D3.js-compatible JSON.</p>"},{"location":"api_reference/#chora.cli.export_dot","title":"<code>export_dot(graph)</code>","text":"<p>Export graph to GraphViz DOT format.</p>"},{"location":"api_reference/#chora.cli.generate_timeline_html","title":"<code>generate_timeline_html(encounters, agent)</code>","text":"<p>Generate simple HTML timeline.</p>"},{"location":"api_reference/#chora.cli.get_graph","title":"<code>get_graph()</code>","text":"<p>Get or create the active graph.</p>"},{"location":"api_reference/#chora.cli.load","title":"<code>load()</code>","text":"<p>Load data into Chora graph.</p>"},{"location":"api_reference/#chora.cli.load_csv","title":"<code>load_csv(file, lon_col, lat_col, name_col)</code>","text":"<p>Load CSV as spatial extents.</p>"},{"location":"api_reference/#chora.cli.load_geojson","title":"<code>load_geojson(file, name_field)</code>","text":"<p>Load GeoJSON as spatial extents.</p>"},{"location":"api_reference/#chora.cli.load_gpx","title":"<code>load_gpx(file, agent, activity)</code>","text":"<p>Load GPX trace as encounters.</p> <p>Each trackpoint becomes an encounter at the corresponding location.</p>"},{"location":"api_reference/#chora.cli.main","title":"<code>main()</code>","text":"<p>CLI entry point.</p>"},{"location":"api_reference/#chora.cli.query","title":"<code>query()</code>","text":"<p>Query the platial graph.</p>"},{"location":"api_reference/#chora.cli.query_familiar","title":"<code>query_familiar(agent, min_val)</code>","text":"<p>Find places where agent has high familiarity.</p>"},{"location":"api_reference/#chora.cli.query_stats","title":"<code>query_stats()</code>","text":"<p>Show graph statistics.</p>"},{"location":"api_reference/#chora.cli.viz","title":"<code>viz()</code>","text":"<p>Visualization and export commands.</p>"},{"location":"api_reference/#chora.cli.viz_export","title":"<code>viz_export(fmt, output)</code>","text":"<p>Export graph for visualization.</p>"},{"location":"api_reference/#chora.cli.viz_timeline","title":"<code>viz_timeline(agent, output)</code>","text":"<p>Generate timeline visualization for an agent.</p>"},{"location":"core_concepts/","title":"Core Concepts","text":""},{"location":"core_concepts/#domain-objects","title":"Domain Objects","text":"<p>Chora formalises nine first-class concepts:</p>"},{"location":"core_concepts/#agent","title":"Agent","text":"<p>An entity with situated experience \u2014 human, group, or proxy.</p> <pre><code>from chora.core import Agent\n\nalice = Agent.individual(\"Alice\", age=30)\nfamily = Agent.group(\"The Smiths\", members=[\"Alice\", \"Bob\"])\n</code></pre>"},{"location":"core_concepts/#spatialextent","title":"SpatialExtent","text":"<p>Weakly semanticised spatial support with geometry.</p> <pre><code>from chora.core import SpatialExtent\n\n# From bounds\npark = SpatialExtent.from_bounds(-0.13, 51.50, -0.12, 51.51, \"Hyde Park\")\n\n# Point location\ncafe = SpatialExtent.point(-0.127, 51.507, \"Corner Cafe\")\n\n# With semantic hints (not strong categories)\npark.set_hint(\"land_use\", \"recreation\")\n</code></pre>"},{"location":"core_concepts/#encounter","title":"Encounter","text":"<p>Spatio-temporal relation between agent and extent.</p> <pre><code>from chora.core import Encounter\nfrom datetime import datetime, timedelta\n\nencounter = Encounter(\n    agent_id=alice.id,\n    extent_id=park.id,\n    start_time=datetime(2024, 6, 15, 10, 0),\n    end_time=datetime(2024, 6, 15, 11, 30),\n    activity=\"walking\",\n    intensity=0.8\n)\n\nprint(f\"Duration: {encounter.duration_hours:.1f} hours\")\n</code></pre>"},{"location":"core_concepts/#context","title":"Context","text":"<p>Situational modifiers \u2014 temporal, social, purposive, environmental.</p> <pre><code>from chora.core import Context\n\nmorning = Context.temporal(\"morning\")\nwith_dog = Context.social(companions=[\"Max the dog\"])\nleisure = Context.purposive(\"leisure walk\")\nsunny = Context.environmental({\"weather\": \"sunny\", \"temperature\": 22})\n</code></pre>"},{"location":"core_concepts/#practice","title":"Practice","text":"<p>Emergent patterns over encounters \u2014 routines, habits, rituals.</p> <pre><code>from chora.core import Practice, PracticeType\n\nmorning_walk = Practice(\n    practice_type=PracticeType.ROUTINE,\n    name=\"Morning park walk\",\n    frequency=0.8,  # ~6 times per week\n    regularity=0.9,\n    typical_time=\"morning (8-12)\"\n)\n</code></pre>"},{"location":"core_concepts/#affect","title":"Affect","text":"<p>Experiential response with valence and arousal.</p> <pre><code>from chora.core import Affect\nfrom chora.core.affect import AffectState\nfrom chora.core.uncertainty import UncertaintyValue\n\npeaceful = Affect(\n    affect_state=AffectState(\n        valence=UncertaintyValue(0.7, 0.1),  # Positive\n        arousal=UncertaintyValue(0.2, 0.1)   # Calm\n    )\n)\nprint(f\"Quadrant: {peaceful.quadrant}\")  # \"calm\"\n</code></pre>"},{"location":"core_concepts/#familiarity","title":"Familiarity","text":"<p>Evolving state that grows with encounters and decays with time.</p> <pre><code>from chora.core import Familiarity\n\nfam = Familiarity(\n    agent_id=alice.id,\n    extent_id=park.id,\n    value=0.75,\n    encounter_count=20\n)\n\n# Reinforce with new encounter\nfam.reinforce(duration_hours=1.5)\n\n# Check current value (with decay applied)\nprint(f\"Current: {fam.current_value:.2f}\")\n</code></pre>"},{"location":"core_concepts/#liminality","title":"Liminality","text":"<p>Transitional quality at boundaries.</p> <pre><code>from chora.core import Liminality, LiminalityType\n\npark_entrance = Liminality.spatial_boundary(\n    from_space=\"street\",\n    to_space=\"park\",\n    intensity=0.9\n)\n</code></pre>"},{"location":"core_concepts/#meaning","title":"Meaning","text":"<p>Symbolic interpretation attached to places.</p> <pre><code>from chora.core import Meaning, MeaningType\n\nchildhood_home = Meaning.personal(\n    agent_id=alice.id,\n    extent_id=house_id,\n    content=\"Where I learned to ride a bike\",\n    symbols=(\"childhood\", \"safety\", \"family\")\n)\n\nmemorial = Meaning.cultural(\n    extent_id=monument_id,\n    content=\"Site of remembrance\",\n    symbols=(\"sacrifice\", \"nation\")\n)\n</code></pre>"},{"location":"core_concepts/#the-platial-graph","title":"The Platial Graph","text":"<p>All objects exist within a <code>PlatialGraph</code>:</p> <pre><code>from chora.core import PlatialGraph, PlatialEdge, EdgeType\n\ngraph = PlatialGraph(name=\"Urban Mobility Study\")\n\n# Add nodes\ngraph.add_node(alice)\ngraph.add_node(park)\ngraph.add_node(encounter)\n\n# Add edges\ngraph.add_edge(PlatialEdge.participates_in(alice.id, encounter.id))\ngraph.add_edge(PlatialEdge.occurs_at(encounter.id, park.id))\n\n# Query\nfor node in graph.nodes(NodeType.ENCOUNTER):\n    print(node)\n</code></pre>"},{"location":"derivation/","title":"Derivation Operators","text":"<p>Derivation operators transform raw data into platial structures. They embody platial theory, not ad-hoc heuristics.</p>"},{"location":"derivation/#encounter-extraction","title":"Encounter Extraction","text":"<p>Extract encounters from GPS traces:</p> <pre><code>from chora.derive import extract_encounters, TracePoint, EncounterExtractionConfig\nfrom datetime import datetime\n\n# GPS trace data\ntrace = [\n    TracePoint(datetime(2024, 1, 1, 10, 0), -0.127, 51.507),\n    TracePoint(datetime(2024, 1, 1, 10, 15), -0.127, 51.507),\n    TracePoint(datetime(2024, 1, 1, 10, 30), -0.127, 51.507),\n    TracePoint(datetime(2024, 1, 1, 11, 0), -0.130, 51.510),\n]\n\n# Extract encounters at predefined extents\nencounters = extract_encounters(trace, agent_id, extents)\n\n# Or cluster without predefined extents\nfrom chora.derive import extract_encounters_from_trace\nencounters = extract_encounters_from_trace(trace, agent_id)\n</code></pre>"},{"location":"derivation/#familiarity-updates","title":"Familiarity Updates","text":"<p>Update familiarity based on encounters:</p> <pre><code>from chora.derive import update_familiarity, compute_familiarity_trajectory\n\n# Update from single encounter\nfamiliarity = update_familiarity(graph, encounter)\nprint(f\"New familiarity: {familiarity.value:.2f}\")\n\n# Compute trajectory over time\ntrajectory = compute_familiarity_trajectory(\n    encounters, agent_id, extent_id,\n    decay_half_life_days=14.0\n)\nfor timestamp, value in trajectory:\n    print(f\"{timestamp}: {value:.2f}\")\n\n# Apply decay to all familiarities\nfrom chora.derive import decay_all_familiarities\ncount = decay_all_familiarities(graph)\n</code></pre>"},{"location":"derivation/#practice-detection","title":"Practice Detection","text":"<p>Detect routines and patterns:</p> <pre><code>from chora.derive import detect_practices, detect_routines, PracticeDetectionConfig\n\nconfig = PracticeDetectionConfig(\n    min_occurrences=3,\n    time_window_days=30,\n    min_regularity=0.5\n)\n\npractices = detect_practices(encounters, agent_id, config)\n\nfor practice in practices:\n    print(f\"{practice.name}: regularity={practice.regularity:.2f}\")\n</code></pre>"},{"location":"derivation/#liminality-inference","title":"Liminality Inference","text":"<p>Detect liminal zones from transitions:</p> <pre><code>from chora.derive import infer_liminality, detect_boundary_crossings\n\nliminal_zones = infer_liminality(encounters, extents)\n\nfor zone in liminal_zones:\n    print(f\"{zone.transitional_from} \u2192 {zone.transitional_to}\")\n    print(f\"  Intensity: {zone.intensity:.2f}\")\n</code></pre>"},{"location":"derivation/#affect-derivation","title":"Affect Derivation","text":"<p>Attach affect from context:</p> <pre><code>from chora.derive import attach_affect, derive_affect_from_context\n\n# Explicit attachment\naffect = attach_affect(encounter, valence=0.7, arousal=0.3, source=\"survey\")\n\n# Derive from context\naffect = derive_affect_from_context(encounter, contexts)\nprint(f\"Derived valence: {affect.valence:.2f}\")\n</code></pre>"},{"location":"derivation/#meaning-derivation","title":"Meaning Derivation","text":"<p>Derive meanings from practices:</p> <pre><code>from chora.derive import attach_meaning, derive_meaning_from_practices\n\n# Explicit attachment\nmeaning = attach_meaning(\n    agent_id, extent_id,\n    content=\"My daily exercise spot\",\n    symbols=[\"health\", \"routine\"]\n)\n\n# Derive from practice patterns\nmeanings = derive_meaning_from_practices(practices, agent_id, extent_id)\n</code></pre>"},{"location":"derivation/#place-emergence","title":"Place Emergence","text":"<p>Extract emergent place as subgraph:</p> <pre><code>from chora.derive import extract_place, find_emergent_places\n\n# Single place for agent-extent pair\nplace = extract_place(graph, extent_id, agent_id)\nprint(f\"Familiarity: {place.familiarity_score:.2f}\")\nprint(f\"Character: {place.character}\")\nprint(f\"Encounter count: {place.encounter_count}\")\n\n# Find all significant places\nplaces = find_emergent_places(graph, agent_id, min_encounters=3)\nfor p in places:\n    print(f\"{p.extent.name}: {p.character}\")\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<pre><code># Create virtual environment\npython3 -m venv .venv\nsource .venv/bin/activate\n\n# Install from source\npip install -e .\n\n# With development dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting_started/#your-first-platial-model","title":"Your First Platial Model","text":"<pre><code>from datetime import datetime, timedelta\nfrom chora.core import (\n    Agent, SpatialExtent, Encounter, PlatialGraph,\n    PlatialEdge, EdgeType\n)\nfrom chora.derive import update_familiarity, extract_place\n\n# 1. Create the world\npark = SpatialExtent.from_bounds(\n    -0.127, 51.507, -0.126, 51.508,\n    name=\"Local Park\"\n)\n\n# 2. Create an agent\nalice = Agent.individual(\"Alice\")\n\n# 3. Build the graph\ngraph = PlatialGraph(name=\"My First Graph\")\ngraph.add_node(park)\ngraph.add_node(alice)\n\n# 4. Record encounters\nfor day in range(5):\n    visit_time = datetime.now() - timedelta(days=7-day)\n\n    encounter = Encounter(\n        agent_id=alice.id,\n        extent_id=park.id,\n        start_time=visit_time,\n        end_time=visit_time + timedelta(hours=1)\n    )\n    graph.add_node(encounter)\n\n    # Add edges\n    graph.add_edge(PlatialEdge.participates_in(alice.id, encounter.id))\n    graph.add_edge(PlatialEdge.occurs_at(encounter.id, park.id))\n\n    # Update derived state\n    update_familiarity(graph, encounter)\n\n# 5. Extract the emergent place\nplace = extract_place(graph, park.id, alice.id)\nprint(f\"Place: {place.extent.name}\")\nprint(f\"Familiarity: {place.familiarity_score:.2f}\")\nprint(f\"Encounters: {place.encounter_count}\")\n</code></pre>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts \u2014 Understanding domain objects</li> <li>Derivation Operators \u2014 Transforming data</li> <li>Examples \u2014 Full working examples</li> </ul>"},{"location":"queries/","title":"Query Interface","text":"<p>Chora provides a fluent query interface for finding and analysing places.</p>"},{"location":"queries/#fluent-query-builder","title":"Fluent Query Builder","text":"<pre><code>from chora.query import PlatialQuery\n\n# Find familiar, positive places\nplaces = (PlatialQuery(graph)\n    .for_agent(alice.id)\n    .with_familiarity(min_value=0.5)\n    .with_positive_affect()\n    .execute())\n\nfor place in places:\n    print(f\"{place.extent.name}: {place.character}\")\n</code></pre>"},{"location":"queries/#convenience-functions","title":"Convenience Functions","text":"<pre><code>from chora.query import (\n    find_familiar_places,\n    find_positive_places,\n    find_routine_places,\n    query_encounters\n)\n\n# Familiar places\nfamiliar = find_familiar_places(graph, alice.id, min_familiarity=0.5)\n\n# Positive places\npositive = find_positive_places(graph, alice.id)\n\n# Routine places (high encounter count)\nroutines = find_routine_places(graph, alice.id, min_encounters=10)\n\n# Query encounters with filters\nfor enc in query_encounters(graph, agent_id=alice.id, extent_id=park.id):\n    print(f\"{enc.start_time}: {enc.activity}\")\n</code></pre>"},{"location":"queries/#pattern-matching","title":"Pattern Matching","text":"<pre><code>from chora.query import find_practices_like, match_pattern\n\n# Find practices similar to a template\nsimilar = find_practices_like(graph, template_practice, min_similarity=0.7)\n\n# Match named patterns\nmorning_routines = match_pattern(graph, \"morning_routine\")\navoidances = match_pattern(graph, \"avoidance\")\nexplorations = match_pattern(graph, \"exploration\")\n</code></pre>"},{"location":"queries/#similarity-measures","title":"Similarity Measures","text":"<pre><code>from chora.query import place_similarity, practice_similarity\n\n# Compare two places\nsim = place_similarity(place_a, place_b)\nprint(f\"Similarity: {sim:.2f}\")\n\n# Compare practices\nsim = practice_similarity(routine_a, routine_b)\n</code></pre>"},{"location":"queries/#graph-traversal","title":"Graph Traversal","text":"<pre><code>from chora.query import traverse_from, find_connected, find_path\nfrom chora.core import EdgeType\n\n# BFS from a node\nfor node, depth in traverse_from(graph, start_id, max_depth=3):\n    print(f\"Depth {depth}: {node}\")\n\n# Find connected nodes\nconnected = find_connected(graph, encounter_id, \n                          edge_types=[EdgeType.HAS_CONTEXT])\n\n# Find path between nodes\npath = find_path(graph, start_id, end_id)\nif path:\n    print(\" \u2192 \".join(str(n) for n in path))\n</code></pre>"},{"location":"queries/#temporal-queries","title":"Temporal Queries","text":"<pre><code>from chora.query import snapshot_query, temporal_range_query\nfrom datetime import datetime, timedelta\n\n# Snapshot at a point in time\npast = datetime.now() - timedelta(days=30)\nsnapshot = snapshot_query(graph, at=past)\nprint(f\"Nodes at {past}: {snapshot.node_count}\")\n\n# Nodes active during a range\nstart = datetime(2024, 1, 1)\nend = datetime(2024, 6, 30)\nfor node in temporal_range_query(graph, start, end):\n    print(node)\n</code></pre>"},{"location":"theory/","title":"Theoretical Foundations","text":""},{"location":"theory/#the-problem-with-place","title":"The Problem with \"Place\"","text":"<p>Traditional GIS treats space as a container with objects located within it. But place is not simply location \u2014 it emerges from:</p> <ul> <li>Repeated encounters between agents and spatial extents</li> <li>Accumulated familiarity that grows and decays</li> <li>Affect \u2014 the emotional character of experience</li> <li>Meaning \u2014 symbolic interpretations attached to locations</li> <li>Practices \u2014 routines and habits that pattern our engagement</li> </ul>"},{"location":"theory/#core-premise","title":"Core Premise","text":"<p>Place is not a primitive. Place emerges.</p> <p>Chora models place as an emergent subgraph from a typed, temporal, heterogeneous graph of encounters, rather than as a predefined spatial category.</p>"},{"location":"theory/#design-principles","title":"Design Principles","text":"Principle Implementation Relational Primacy Platial qualities on edges, not nodes Encounter-Centricity Encounters as first-class objects Epistemic Separation OBSERVED \u2192 DERIVED \u2192 INTERPRETED Probabilistic Representation Uncertainty throughout Temporal Explicitness All entities have lifetimes Theory-Encoded Computation Derivations embody platial theory"},{"location":"theory/#the-platial-graph","title":"The Platial Graph","text":"<pre><code>Agent \u2500\u2500PARTICIPATES_IN\u2500\u2500\u25ba Encounter \u2500\u2500OCCURS_AT\u2500\u2500\u25ba SpatialExtent\n                              \u2502\n                              \u251c\u2500\u2500HAS_CONTEXT\u2500\u2500\u25ba Context\n                              \u251c\u2500\u2500EXPRESSES\u2500\u2500\u25ba Affect\n                              \u251c\u2500\u2500REINFORCES\u2500\u2500\u25ba Familiarity\n                              \u2514\u2500\u2500BELONGS_TO\u2500\u2500\u25ba Practice\n</code></pre>"},{"location":"theory/#epistemic-levels","title":"Epistemic Levels","text":"<p>All data is explicitly categorised:</p> <ul> <li>OBSERVED \u2014 Direct measurements (GPS traces, check-ins)</li> <li>DERIVED \u2014 Computed from observations (familiarity scores)</li> <li>INTERPRETED \u2014 Semantic/symbolic meanings</li> </ul> <p>This separation ensures that uncertainty and provenance are preserved through all transformations.</p>"},{"location":"theory/#familiarity-dynamics","title":"Familiarity Dynamics","text":"<p>Familiarity is modelled with: - Reinforcement on each encounter (saturating growth) - Decay over time without encounters (exponential)</p> <pre><code># After 5 visits\nfamiliarity = 0.16\n\n# After 14 days without visits\nfamiliarity = 0.08  # Decayed by half\n</code></pre>"},{"location":"theory/#place-emergence","title":"Place Emergence","text":"<p>A \"place\" in Chora is not a stored entity but a computed view:</p> <pre><code>place = extract_place(graph, extent_id, agent_id)\n# Returns: EmergentPlace with familiarity, affect, meanings\n</code></pre> <p>This allows multiple agents to have different \"places\" at the same location.</p>"},{"location":"guides/","title":"Guides","text":"<p>Practical tutorials for real-world Chora applications.</p>"},{"location":"guides/#quick-tutorials","title":"Quick Tutorials","text":"<ul> <li> <p>:material-walk: GPS to Places</p> <p>Process GPS traces into meaningful places with familiarity scores.</p> <p>20 min \u2022 Beginner</p> </li> <li> <p>:material-emoticon-happy: Affective Mapping</p> <p>Map emotional qualities to places and query by \"vibe\".</p> <p>25 min \u2022 Intermediate</p> </li> <li> <p>:material-calendar-clock: Detecting Routines</p> <p>Identify habits, routines, and rituals from mobility data.</p> <p>30 min \u2022 Intermediate</p> </li> <li> <p>:material-graph: Visualizing Place Networks</p> <p>Create interactive D3.js graphs and HTML reports.</p> <p>15 min \u2022 Beginner</p> </li> </ul>"},{"location":"guides/#advanced-topics","title":"Advanced Topics","text":"<ul> <li> <p>:material-hexagon-multiple: H3 Spatial Indexing</p> <p>Use hexagonal grids for multi-resolution place analysis.</p> </li> <li> <p>:material-magnify: Semantic Search</p> <p>\"Vibe search\" using vector embeddings to find places by description.</p> </li> <li> <p>:material-robot: LLM Narratives</p> <p>Generate place descriptions with OpenAI/Anthropic/Ollama.</p> </li> <li> <p>:material-wifi: Real-time Streaming</p> <p>Process live GPS with WebSocket and dwell detection.</p> </li> </ul>"},{"location":"guides/affective-mapping/","title":"Affective Mapping","text":"<p>Map emotional qualities to places and query by \"vibe\".</p>"},{"location":"guides/affective-mapping/#what-is-affect","title":"What is Affect?","text":"<p>Affect in Chora represents the emotional quality of a place experience. It uses the psychological circumplex model with two dimensions:</p> Dimension Range Low High Valence -1 to +1 Negative (fear, sadness) Positive (joy, peace) Arousal -1 to +1 Calm (rest, meditation) Excited (thrill, energy) <pre><code>                High Arousal (+1)\n                     \u2191\n         Tense   \u2502   Excited\n                 \u2502\nLow Valence \u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500 High Valence\n(-1)             \u2502            (+1)\n         Sad    \u2502   Content\n                 \u2193\n               Low Arousal (-1)\n</code></pre>"},{"location":"guides/affective-mapping/#step-1-create-affect-nodes","title":"Step 1: Create Affect Nodes","text":"<pre><code>from chora.core import PlatialGraph, SpatialExtent, Affect\n\n# Create graph with places\ngraph = PlatialGraph(name=\"city_feels\")\n\n# A peaceful park (positive, calm)\npark = SpatialExtent.from_bounds(-0.1, 51.5, -0.09, 51.51, name=\"Quiet Park\")\ngraph.add_node(park)\n\npark_affect = Affect(\n    extent_id=park.id,\n    valence=0.8,   # Very positive\n    arousal=-0.3,  # Calm\n    labels=[\"peaceful\", \"restorative\", \"nature\"]\n)\ngraph.add_node(park_affect)\n\n# A busy market (positive, energetic)\nmarket = SpatialExtent.from_bounds(-0.08, 51.52, -0.07, 51.53, name=\"Borough Market\")\ngraph.add_node(market)\n\nmarket_affect = Affect(\n    extent_id=market.id,\n    valence=0.6,   # Positive\n    arousal=0.7,   # Energetic\n    labels=[\"vibrant\", \"social\", \"exciting\"]\n)\ngraph.add_node(market_affect)\n\n# A dark alley (negative, tense)\nalley = SpatialExtent.from_point(-0.085, 51.515, name=\"Dark Alley\")\ngraph.add_node(alley)\n\nalley_affect = Affect(\n    extent_id=alley.id,\n    valence=-0.6,  # Negative\n    arousal=0.4,   # Tense\n    labels=[\"unsafe\", \"avoid\", \"uncomfortable\"]\n)\ngraph.add_node(alley_affect)\n</code></pre>"},{"location":"guides/affective-mapping/#step-2-query-by-affect","title":"Step 2: Query by Affect","text":""},{"location":"guides/affective-mapping/#find-positive-places","title":"Find Positive Places","text":"<pre><code>from chora.query import PlatialQuery\n\n# Find all places with positive affect (valence &gt; 0.5)\nquery = PlatialQuery(graph)\nhappy_places = query.filter_extent_by_affect(\n    min_valence=0.5\n).execute()\n\nfor place in happy_places:\n    print(f\"\u2713 {place.name}\")\n# \u2713 Quiet Park\n# \u2713 Borough Market\n</code></pre>"},{"location":"guides/affective-mapping/#find-calm-places","title":"Find Calm Places","text":"<pre><code># Find relaxing spots (low arousal, positive valence)\ncalm_places = query.filter_extent_by_affect(\n    min_valence=0.3,\n    max_arousal=0.0\n).execute()\n\nfor place in calm_places:\n    print(f\"\ud83d\ude0c {place.name}\")\n# \ud83d\ude0c Quiet Park\n</code></pre>"},{"location":"guides/affective-mapping/#avoid-negative-places","title":"Avoid Negative Places","text":"<pre><code># Find places to avoid\navoid = query.filter_extent_by_affect(\n    max_valence=-0.3\n).execute()\n\nfor place in avoid:\n    print(f\"\u26a0\ufe0f {place.name}\")\n# \u26a0\ufe0f Dark Alley\n</code></pre>"},{"location":"guides/affective-mapping/#step-3-vibe-search-with-embeddings","title":"Step 3: Vibe Search with Embeddings","text":"<p>Go beyond simple filters\u2014search places by semantic description.</p> <pre><code>from chora.search import vibe_search, build_place_index\n\n# Build the search index (requires sentence-transformers)\nindex = build_place_index(graph)\n\n# Search by vibe description\nresults = vibe_search(\n    graph,\n    query=\"quiet peaceful place for reading and relaxation\",\n    top_k=3,\n    index=index\n)\n\nfor extent, similarity in results:\n    print(f\"{extent.name}: {similarity:.2f}\")\n# Quiet Park: 0.87\n# Borough Market: 0.31\n# Dark Alley: 0.12\n</code></pre>"},{"location":"guides/affective-mapping/#more-vibe-queries","title":"More Vibe Queries","text":"<pre><code># Find energetic social spots\nlively = vibe_search(graph, \"busy exciting place with lots of people\")\n# Borough Market: 0.82\n\n# Find cozy refuge\ncozy = vibe_search(graph, \"cozy safe comfortable shelter\")\n# Quiet Park: 0.71\n</code></pre>"},{"location":"guides/affective-mapping/#step-4-aggregate-affect-over-time","title":"Step 4: Aggregate Affect Over Time","text":"<p>Place affect can change based on experiences over time:</p> <pre><code>from chora.derive.affect import aggregate_affect\nfrom chora.core.types import NodeType\n\n# Collect all affect annotations for a place\naffects = [\n    node for node in graph.nodes(NodeType.AFFECT)\n    if str(node.extent_id) == str(park.id)\n]\n\n# Aggregate with recency weighting\noverall = aggregate_affect(affects, decay_rate=0.1)\n\nprint(f\"Park's current vibe:\")\nprint(f\"  Valence: {overall.valence:.2f}\")\nprint(f\"  Arousal: {overall.arousal:.2f}\")\nprint(f\"  Confidence: {overall.confidence:.2f}\")\n</code></pre>"},{"location":"guides/affective-mapping/#complete-example","title":"Complete Example","text":"<pre><code>\"\"\"Affective mapping workflow.\"\"\"\nfrom chora.core import PlatialGraph, Agent, SpatialExtent, Encounter, Affect, PlatialEdge\nfrom chora.search import vibe_search\n\ndef create_affective_map():\n    graph = PlatialGraph(name=\"emotional_city\")\n    me = Agent.individual(\"me\")\n    graph.add_node(me)\n\n    # Define places with affect\n    places = [\n        {\"name\": \"Home\", \"lon\": -0.1, \"lat\": 51.5, \"valence\": 0.9, \"arousal\": -0.4, \"labels\": [\"safe\", \"comfort\"]},\n        {\"name\": \"Office\", \"lon\": -0.08, \"lat\": 51.52, \"valence\": 0.2, \"arousal\": 0.5, \"labels\": [\"stress\", \"focus\"]},\n        {\"name\": \"Gym\", \"lon\": -0.09, \"lat\": 51.51, \"valence\": 0.7, \"arousal\": 0.8, \"labels\": [\"energy\", \"strength\"]},\n        {\"name\": \"Library\", \"lon\": -0.11, \"lat\": 51.49, \"valence\": 0.6, \"arousal\": -0.5, \"labels\": [\"quiet\", \"focus\"]},\n        {\"name\": \"Pub\", \"lon\": -0.085, \"lat\": 51.515, \"valence\": 0.8, \"arousal\": 0.6, \"labels\": [\"social\", \"fun\"]},\n    ]\n\n    for p in places:\n        extent = SpatialExtent.from_point(p[\"lon\"], p[\"lat\"], name=p[\"name\"])\n        graph.add_node(extent)\n\n        affect = Affect(\n            extent_id=extent.id,\n            valence=p[\"valence\"],\n            arousal=p[\"arousal\"],\n            labels=p[\"labels\"]\n        )\n        graph.add_node(affect)\n\n    return graph\n\n# Create and query\ngraph = create_affective_map()\n\n# Find a place to unwind after work\nresults = vibe_search(graph, \"relaxing place to decompress after stressful day\")\nprint(\"Best places to unwind:\")\nfor extent, score in results[:3]:\n    print(f\"  {extent.name}: {score:.2f}\")\n</code></pre>"},{"location":"guides/affective-mapping/#next-steps","title":"Next Steps","text":"<ul> <li>GPS to Places \u2014 Process real location data</li> <li>Practice Detection \u2014 Find patterns in behavior</li> <li>LLM Narratives \u2014 Generate place descriptions</li> </ul>"},{"location":"guides/gps-to-places/","title":"GPS to Places","text":"<p>Turn raw GPS traces into meaningful places with familiarity scores.</p>"},{"location":"guides/gps-to-places/#overview","title":"Overview","text":"<p>Most location data comes as timestamped coordinates\u2014GPS traces from phones, fitness trackers, or vehicle telemetry. Chora transforms these raw points into meaningful places by detecting where people dwell, building familiarity over repeated visits, and creating a graph of platial relationships.</p> <pre><code>graph LR\n    A[GPS Points] --&gt; B[Encounters]\n    B --&gt; C[Dwell Detection]\n    C --&gt; D[Spatial Extents]\n    D --&gt; E[Familiarity Scores]\n    E --&gt; F[Emergent Places]</code></pre>"},{"location":"guides/gps-to-places/#step-1-load-gps-data","title":"Step 1: Load GPS Data","text":""},{"location":"guides/gps-to-places/#from-gpx-files","title":"From GPX Files","text":"<pre><code>import gpxpy\nfrom chora.core import PlatialGraph, Agent, SpatialExtent, Encounter, PlatialEdge\nfrom datetime import datetime\n\n# Create graph and agent\ngraph = PlatialGraph(name=\"my_walks\")\nalice = Agent.individual(\"alice\")\ngraph.add_node(alice)\n\n# Parse GPX\nwith open(\"morning_walk.gpx\") as f:\n    gpx = gpxpy.parse(f)\n\nfor track in gpx.tracks:\n    for segment in track.segments:\n        for point in segment.points:\n            # Create spatial extent for this point\n            extent = SpatialExtent.from_point(\n                lon=point.longitude,\n                lat=point.latitude,\n                name=f\"pt_{point.time.isoformat()}\"\n            )\n            graph.add_node(extent)\n\n            # Create encounter\n            encounter = Encounter(\n                agent_id=alice.id,\n                extent_id=extent.id,\n                start_time=point.time,\n                activity=\"walking\"\n            )\n            graph.add_node(encounter)\n\n            # Link agent \u2192 encounter \u2192 extent\n            graph.add_edge(PlatialEdge.participates_in(alice.id, encounter.id))\n            graph.add_edge(PlatialEdge.occurs_at(encounter.id, extent.id))\n</code></pre>"},{"location":"guides/gps-to-places/#using-the-cli","title":"Using the CLI","text":"<pre><code>chora load gpx morning_walk.gpx --agent alice --activity walking\n</code></pre>"},{"location":"guides/gps-to-places/#step-2-cluster-into-dwells","title":"Step 2: Cluster Into Dwells","text":"<p>Raw GPS points are noisy. We need to cluster nearby points into dwells\u2014locations where someone stayed for a meaningful duration.</p> <pre><code>from chora.streaming import StreamProcessor, StreamConfig, LocationEvent\n\n# Configure dwell detection\nconfig = StreamConfig(\n    dwell_radius_m=50.0,     # Points within 50m are same place\n    dwell_time_s=60.0,       # 60 seconds to trigger a dwell\n    min_dwell_for_encounter=120.0  # 2 min to create encounter\n)\n\nprocessor = StreamProcessor(graph, config)\n\n# Process locations\nfor point in gps_points:\n    event = LocationEvent(\n        agent_id=\"alice\",\n        longitude=point.lon,\n        latitude=point.lat,\n        timestamp=point.time\n    )\n    events = processor.process(event)\n\n    for e in events:\n        if e.event_type == \"encounter\":\n            print(f\"Dwell detected at {e.data['location']}\")\n</code></pre>"},{"location":"guides/gps-to-places/#step-3-derive-familiarity","title":"Step 3: Derive Familiarity","text":"<p>Familiarity grows with repeated visits and decays over time without reinforcement.</p> <pre><code>from chora.derive import update_familiarity\nfrom chora.core.types import NodeType\n\n# Update familiarity for all encounters\nfor encounter in graph.nodes(NodeType.ENCOUNTER):\n    update_familiarity(graph, encounter)\n\n# Check familiarity scores\nfrom chora.query import find_familiar_places, AgentId\n\nfamiliar = find_familiar_places(\n    graph, \n    AgentId(str(alice.id)), \n    min_familiarity=0.5\n)\n\nfor place in familiar:\n    print(f\"{place.extent.name}: {place.familiarity:.2f}\")\n</code></pre> <p>Output: <pre><code>home: 0.95\ncoffee_shop: 0.72\npark: 0.58\n</code></pre></p>"},{"location":"guides/gps-to-places/#step-4-extract-emergent-places","title":"Step 4: Extract Emergent Places","text":"<p>Places emerge from patterns of encounters\u2014they're not predefined, they're discovered.</p> <pre><code>from chora.derive.place import extract_place\n\n# Extract place for a spatial extent based on alice's encounters\nplace = extract_place(graph, extent_id=park.id, agent_id=alice.id)\n\nprint(f\"Place: {place.name}\")\nprint(f\"Visit count: {place.encounter_count}\")\nprint(f\"Familiarity: {place.familiarity}\")\nprint(f\"Character: {place.semantic_hints}\")\n</code></pre>"},{"location":"guides/gps-to-places/#complete-example","title":"Complete Example","text":"<pre><code>\"\"\"Full GPS-to-Places pipeline.\"\"\"\nfrom chora.core import PlatialGraph, Agent, SpatialExtent, Encounter, PlatialEdge\nfrom chora.derive import update_familiarity\nfrom chora.query import find_familiar_places\nfrom chora.streaming import create_processor\nimport gpxpy\n\ndef process_gpx(gpx_path: str, agent_name: str = \"user\"):\n    # Setup\n    graph = PlatialGraph(name=\"locations\")\n    agent = Agent.individual(agent_name)\n    graph.add_node(agent)\n\n    # Create streaming processor for dwell detection\n    processor = create_processor(\n        graph,\n        dwell_radius=50.0,  # meters\n        dwell_time=60.0     # seconds\n    )\n\n    # Load and process GPS\n    with open(gpx_path) as f:\n        gpx = gpxpy.parse(f)\n\n    for track in gpx.tracks:\n        for segment in track.segments:\n            for point in segment.points:\n                from chora.streaming import LocationEvent\n\n                event = LocationEvent(\n                    agent_id=agent_name,\n                    longitude=point.longitude,\n                    latitude=point.latitude,\n                    timestamp=point.time\n                )\n                processor.process(event)\n\n    # Derive familiarity\n    from chora.core.types import NodeType\n    for enc in graph.nodes(NodeType.ENCOUNTER):\n        update_familiarity(graph, enc)\n\n    # Query results\n    from chora.core.types import AgentId\n    places = find_familiar_places(graph, AgentId(agent_name), min_familiarity=0.3)\n\n    return graph, places\n\n# Run\ngraph, places = process_gpx(\"my_track.gpx\", \"alice\")\nfor p in places:\n    print(f\"{p.extent.name}: {p.familiarity:.2f}\")\n</code></pre>"},{"location":"guides/gps-to-places/#next-steps","title":"Next Steps","text":"<ul> <li>Affective Mapping \u2014 Add emotional qualities</li> <li>Practice Detection \u2014 Find routines in your data</li> <li>CLI Reference \u2014 Full CLI documentation</li> </ul>"},{"location":"guides/h3-indexing/","title":"H3 Spatial Indexing","text":"<p>Use hexagonal grids for multi-resolution place analysis.</p>"},{"location":"guides/h3-indexing/#what-is-h3","title":"What is H3?","text":"<p>H3 is Uber's hexagonal hierarchical spatial index. Unlike traditional grids, hexagons provide:</p> <ul> <li>Equal distance to all neighbors (no diagonal bias)</li> <li>Hierarchical resolution (0-15, where 0 is ~1107km, 15 is ~0.5m)</li> <li>Compact representation of arbitrary shapes</li> </ul>"},{"location":"guides/h3-indexing/#resolution-guide","title":"Resolution Guide","text":"Resolution Edge Length Use Case 0 ~1107 km Continental 3 ~59 km Metropolitan area 6 ~3 km Neighborhood 9 ~174 m Building cluster 10 ~65 m Building 12 ~9 m Room 15 ~0.5 m Very precise"},{"location":"guides/h3-indexing/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/h3-indexing/#create-h3-extent-from-point","title":"Create H3 Extent from Point","text":"<pre><code>from chora.core.h3 import H3SpatialExtent\n\n# Create at resolution 9 (~174m)\nhex_extent = H3SpatialExtent.from_point_h3(\n    lon=-0.1276,\n    lat=51.5074,\n    resolution=9,\n    name=\"London Center\"\n)\n\nprint(f\"H3 Index: {hex_extent.h3_index}\")\nprint(f\"Resolution: {hex_extent.resolution}\")\nprint(f\"Centroid: {hex_extent.centroid}\")\n</code></pre>"},{"location":"guides/h3-indexing/#convert-existing-extent-to-h3","title":"Convert Existing Extent to H3","text":"<pre><code>from chora.core.h3 import extent_to_h3, h3_to_extent\nfrom chora.core import SpatialExtent\n\n# Regular extent\npark = SpatialExtent.from_bounds(-0.1, 51.5, -0.09, 51.51, name=\"Park\")\n\n# Get covering H3 cells\ncells = extent_to_h3(park, resolution=10)\nprint(f\"Park covers {len(cells)} hexagons\")\n\n# Convert back\nfor cell in cells[:3]:\n    hex_ext = h3_to_extent(cell)\n    print(f\"  {cell[:8]}... ({hex_ext.centroid})\")\n</code></pre>"},{"location":"guides/h3-indexing/#spatial-queries","title":"Spatial Queries","text":""},{"location":"guides/h3-indexing/#neighbors","title":"Neighbors","text":"<pre><code># Get immediate neighbors (ring 1)\nneighbors = hex_extent.neighbors\nprint(f\"6 neighbors: {len(neighbors)}\")\n\n# Get k-ring (all cells within k hops)\nk_ring = hex_extent.k_ring(k=2)\nprint(f\"Cells within 2 rings: {len(k_ring)}\")  # 19 cells\n</code></pre>"},{"location":"guides/h3-indexing/#hierarchy","title":"Hierarchy","text":"<pre><code># Go up a resolution level\nparent = hex_extent.parent\nprint(f\"Parent (res {hex_extent.resolution - 1}): {parent[:8]}...\")\n\n# Go down a resolution level  \nchildren = hex_extent.children\nprint(f\"Children (res {hex_extent.resolution + 1}): {len(children)} cells\")\n</code></pre>"},{"location":"guides/h3-indexing/#distance","title":"Distance","text":"<pre><code>other = H3SpatialExtent.from_point_h3(-0.1, 51.5, resolution=9)\ndistance = hex_extent.distance_to_h3(other)\nprint(f\"Grid distance: {distance} cells\")\n</code></pre>"},{"location":"guides/h3-indexing/#multi-resolution-analysis","title":"Multi-Resolution Analysis","text":"<p>Analyze the same area at different resolutions:</p> <pre><code>from chora.core.h3 import point_to_h3, H3_RESOLUTION_GUIDE\n\nlon, lat = -0.1276, 51.5074\n\nfor res in [6, 9, 12]:\n    cell = point_to_h3(lon, lat, res)\n    desc = H3_RESOLUTION_GUIDE.get(res, \"\")\n    print(f\"Resolution {res}: {cell[:12]}... ({desc})\")\n</code></pre> <p>Output: <pre><code>Resolution 6: 861203a4ff... (~3 km edge, neighborhood)\nResolution 9: 891203a4c1... (~174 m edge, building cluster)\nResolution 12: 8c1203a4c1... (~9 m edge, room)\n</code></pre></p>"},{"location":"guides/h3-indexing/#scale-based-resolution","title":"Scale-Based Resolution","text":"<pre><code>from chora.core.h3 import resolution_for_scale\n\n# Get appropriate resolution for your scale\ncity_res = resolution_for_scale(\"city\")         # 4\nneighborhood_res = resolution_for_scale(\"neighborhood\")  # 6\nbuilding_res = resolution_for_scale(\"building\")      # 10\n\nprint(f\"City analysis: resolution {city_res}\")\nprint(f\"Neighborhood: resolution {neighborhood_res}\")\nprint(f\"Building level: resolution {building_res}\")\n</code></pre>"},{"location":"guides/h3-indexing/#compact-representation","title":"Compact Representation","text":"<p>Efficiently represent large areas:</p> <pre><code>from chora.core.h3 import compact_h3_cells, uncompact_h3_cells\n\n# Lots of small cells\ncells = hex_extent.k_ring(k=5)\nprint(f\"Original: {len(cells)} cells\")\n\n# Compact to minimal representation\ncompacted = compact_h3_cells(cells)\nprint(f\"Compacted: {len(compacted)} cells\")\n\n# Expand back to original resolution\nexpanded = uncompact_h3_cells(compacted, hex_extent.resolution)\nprint(f\"Expanded: {len(expanded)} cells\")\n</code></pre>"},{"location":"guides/h3-indexing/#complete-example","title":"Complete Example","text":"<pre><code>\"\"\"H3 spatial indexing for place analysis.\"\"\"\nfrom chora.core import PlatialGraph, Agent\nfrom chora.core.h3 import (\n    H3SpatialExtent, \n    extent_to_h3, \n    resolution_for_scale\n)\n\ndef analyze_area_at_scales(lon: float, lat: float, name: str = \"Location\"):\n    \"\"\"Multi-resolution analysis of a location.\"\"\"\n\n    graph = PlatialGraph(name=f\"{name}_analysis\")\n\n    scales = [\"neighborhood\", \"block\", \"building\"]\n\n    for scale in scales:\n        res = resolution_for_scale(scale)\n        hex_ext = H3SpatialExtent.from_point_h3(lon, lat, resolution=res, name=f\"{name}_{scale}\")\n        graph.add_node(hex_ext)\n\n        print(f\"\\n{scale.upper()} (resolution {res}):\")\n        print(f\"  H3: {hex_ext.h3_index}\")\n        print(f\"  Neighbors: {len(hex_ext.neighbors)}\")\n        print(f\"  K-ring(2): {len(hex_ext.k_ring(2))} cells\")\n\n    return graph\n\n# Analyze central London\ngraph = analyze_area_at_scales(-0.1276, 51.5074, \"Westminster\")\n</code></pre>"},{"location":"guides/h3-indexing/#installation","title":"Installation","text":"<p>H3 requires the <code>h3</code> Python package:</p> <pre><code>pip install h3\n</code></pre>"},{"location":"guides/h3-indexing/#next-steps","title":"Next Steps","text":"<ul> <li>GPS to Places \u2014 Process GPS into H3 cells</li> <li>Vibe Search \u2014 Search H3 cells by semantic content</li> <li>Streaming \u2014 Real-time H3 cell tracking</li> </ul>"},{"location":"guides/llm-integration/","title":"LLM Integration","text":"<p>Generate natural language narratives about places using Large Language Models.</p>"},{"location":"guides/llm-integration/#why-narratives","title":"Why Narratives?","text":"<p>Maps give you coordinates. Narratives give you meaning.</p> <p>Chora integrates with LLMs (OpenAI, Anthropic, Ollama) to translate platial graphs into human stories: - Describe a place's character - Narrate a journey through the city - Interpret why a place feels familiar</p>"},{"location":"guides/llm-integration/#setup","title":"Setup","text":"<pre><code>from chora.llm import NarrativeGenerator, OllamaProvider, OpenAIProvider\n\n# Option 1: Local LLM (Free, Private)\n# Requires Ollama running (ollama serve)\nprovider = OllamaProvider(model=\"llama3.2\")\n\n# Option 2: OpenAI (High Quality)\n# provider = OpenAIProvider(api_key=\"sk-...\", model=\"gpt-4\")\n\ngen = NarrativeGenerator(provider=provider)\n</code></pre>"},{"location":"guides/llm-integration/#1-describe-a-place","title":"1. Describe a Place","text":"<p>Generates a description based on the place's hints, affect, and history.</p> <pre><code>from chora.llm import describe_place\n\ndescription = describe_place(\n    graph, \n    park, \n    style=\"poetic\"  # or \"descriptive\", \"analytical\"\n)\n\nprint(description)\n</code></pre> <p>The park breathes with a quiet calm, anchored by the rustling oak trees. It is a place of deep familiarity, visited often in the morning hours, carrying an air of restoration and peace.</p>"},{"location":"guides/llm-integration/#2-narrate-a-journey","title":"2. Narrate a Journey","text":"<p>Turn a sequence of visits into a travelogue.</p> <pre><code>from chora.llm import narrate_journey\n\n# List of places visited\nroute = [home, station, coffee_shop, office]\n\nstory = narrate_journey(graph, route, agent_name=\"Alice\")\nprint(story)\n</code></pre> <p>Alice began her day at the sanctuary of Home, before stepping into the chaotic rhythm of the Station. The sensory transition was sharp\u2014from quiet comfort to the mechanical hum of transit. A brief respite followed at the Coffee Shop, a ritual pause, before the final transition into the focused energy of the Office.</p>"},{"location":"guides/llm-integration/#3-interpret-familiarity","title":"3. Interpret Familiarity","text":"<p>Explain why a place is familiar.</p> <pre><code>explanation = gen.interpret_familiarity(graph, work, score=0.95)\nprint(explanation)\n</code></pre> <p>With a score of 0.95, this place is deeply familiar\u2014an anchor in your daily life. It is not just a location but a habit, reinforced by daily presence. Such high familiarity suggests it shape your identity as much as you inhabit it.</p>"},{"location":"guides/llm-integration/#supported-models","title":"Supported Models","text":"Provider Models Best For Ollama <code>llama3</code>, <code>mistral</code> Local dev, privacy, cost OpenAI <code>gpt-4o</code>, <code>gpt-3.5</code> High quality narratives Anthropic <code>claude-3-opus</code> Nuanced, poetic descriptions"},{"location":"guides/llm-integration/#next-steps","title":"Next Steps","text":"<ul> <li>H3 Indexing \u2014 Analyze places at scale before narrating</li> <li>Vibe Search \u2014 Find places to write about</li> </ul>"},{"location":"guides/practice-detection/","title":"Detecting Routines &amp; Practices","text":"<p>Identify habits, routines, and rituals from mobility patterns.</p>"},{"location":"guides/practice-detection/#what-are-practices","title":"What Are Practices?","text":"<p>Practices in Chora are recurring patterns of behavior that emerge from temporal regularities in encounters:</p> Type Definition Example Routine High-frequency, predictable patterns Daily commute Habit Consistent behavior at certain times Morning coffee run Ritual Less frequent but meaningful patterns Sunday park visit Sequence Linked place transitions Home \u2192 Gym \u2192 Work"},{"location":"guides/practice-detection/#step-1-prepare-encounter-data","title":"Step 1: Prepare Encounter Data","text":"<pre><code>from chora.core import PlatialGraph, Agent, SpatialExtent, Encounter, PlatialEdge\nfrom datetime import datetime, timedelta\n\ngraph = PlatialGraph(name=\"my_patterns\")\nalice = Agent.individual(\"alice\")\ngraph.add_node(alice)\n\n# Create places\nhome = SpatialExtent.from_point(-0.1, 51.5, name=\"Home\")\nwork = SpatialExtent.from_point(-0.08, 51.52, name=\"Office\")\ncoffee = SpatialExtent.from_point(-0.079, 51.518, name=\"Coffee Shop\")\ngym = SpatialExtent.from_point(-0.09, 51.51, name=\"Gym\")\n\nfor place in [home, work, coffee, gym]:\n    graph.add_node(place)\n\n# Simulate 2 weeks of encounters\nbase_date = datetime(2024, 1, 1)\n\nfor day in range(14):\n    date = base_date + timedelta(days=day)\n    weekday = date.weekday()\n\n    # Daily: Home morning\n    enc = Encounter(agent_id=alice.id, extent_id=home.id, \n                    start_time=date.replace(hour=7), activity=\"morning\")\n    graph.add_node(enc)\n\n    # Weekdays: Coffee \u2192 Work\n    if weekday &lt; 5:\n        enc = Encounter(agent_id=alice.id, extent_id=coffee.id,\n                        start_time=date.replace(hour=8), activity=\"coffee\")\n        graph.add_node(enc)\n\n        enc = Encounter(agent_id=alice.id, extent_id=work.id,\n                        start_time=date.replace(hour=9), activity=\"work\")\n        graph.add_node(enc)\n\n    # MWF: Gym after work\n    if weekday in [0, 2, 4]:\n        enc = Encounter(agent_id=alice.id, extent_id=gym.id,\n                        start_time=date.replace(hour=18), activity=\"exercise\")\n        graph.add_node(enc)\n</code></pre>"},{"location":"guides/practice-detection/#step-2-detect-practices","title":"Step 2: Detect Practices","text":"<pre><code>from chora.derive.practices import detect_practices, PracticeDetectionConfig\nfrom chora.core.types import NodeType\n\n# Gather all encounters for the agent\nencounters = [\n    node for node in graph.nodes(NodeType.ENCOUNTER)\n    if hasattr(node, 'agent_id') and str(node.agent_id) == str(alice.id)\n]\n\n# Configure detection\nconfig = PracticeDetectionConfig(\n    min_occurrences=3,          # At least 3 times\n    time_tolerance_hours=2,     # Within 2 hours counts as same time\n    min_regularity=0.5          # 50% of opportunities\n)\n\n# Detect\npractices = detect_practices(encounters, alice.id, config)\n\nfor practice in practices:\n    print(f\"\ud83d\udcc5 {practice.name}\")\n    print(f\"   Type: {practice.practice_type}\")\n    print(f\"   Regularity: {practice.regularity:.0%}\")\n    print(f\"   Occurrences: {practice.occurrence_count}\")\n    print()\n</code></pre> <p>Output: <pre><code>\ud83d\udcc5 morning_routine\n   Type: ROUTINE\n   Regularity: 100%\n   Occurrences: 14\n\n\ud83d\udcc5 weekday_coffee\n   Type: HABIT  \n   Regularity: 100%\n   Occurrences: 10\n\n\ud83d\udcc5 gym_session\n   Type: HABIT\n   Regularity: 43%\n   Occurrences: 6\n</code></pre></p>"},{"location":"guides/practice-detection/#step-3-detect-sequences","title":"Step 3: Detect Sequences","text":"<p>Find common place-to-place transitions:</p> <pre><code>from chora.derive.practices import detect_sequences\n\nsequences = detect_sequences(encounters, min_support=3)\n\nfor seq in sequences:\n    places = \" \u2192 \".join(seq.place_names)\n    print(f\"\ud83d\udd17 {places}\")\n    print(f\"   Support: {seq.support}\")\n    print()\n</code></pre> <p>Output: <pre><code>\ud83d\udd17 Home \u2192 Coffee Shop \u2192 Office\n   Support: 10\n\n\ud83d\udd17 Office \u2192 Gym \u2192 Home\n   Support: 6\n</code></pre></p>"},{"location":"guides/practice-detection/#step-4-analyze-temporal-patterns","title":"Step 4: Analyze Temporal Patterns","text":"<pre><code>from chora.derive.practices import analyze_temporal_distribution\n\n# When does alice visit the gym?\ngym_encounters = [e for e in encounters if str(e.extent_id) == str(gym.id)]\ndistribution = analyze_temporal_distribution(gym_encounters)\n\nprint(\"Gym visit patterns:\")\nprint(f\"  Typical day: {distribution.most_common_day}\")\nprint(f\"  Typical hour: {distribution.most_common_hour}\")\nprint(f\"  Day distribution: {distribution.day_counts}\")\n</code></pre> <p>Output: <pre><code>Gym visit patterns:\n  Typical day: Monday\n  Typical hour: 18\n  Day distribution: {0: 2, 2: 2, 4: 2}  # Mon, Wed, Fri\n</code></pre></p>"},{"location":"guides/practice-detection/#cli-usage","title":"CLI Usage","text":"<pre><code># Detect practices for an agent\nchora derive practices --agent alice --min-occurrences 3\n\n# Output\n# Found 3 practices:\n#   morning_routine (ROUTINE): 100% regularity\n#   weekday_coffee (HABIT): 100% regularity  \n#   gym_session (HABIT): 43% regularity\n</code></pre>"},{"location":"guides/practice-detection/#complete-example","title":"Complete Example","text":"<pre><code>\"\"\"Practice detection from GPS data.\"\"\"\nfrom chora.core import PlatialGraph, Agent\nfrom chora.derive.practices import detect_practices, PracticeDetectionConfig\nfrom chora.core.types import NodeType\n\ndef analyze_routines(graph: PlatialGraph, agent_name: str):\n    \"\"\"Analyze all routines for an agent.\"\"\"\n\n    # Get agent\n    agents = [n for n in graph.nodes(NodeType.AGENT) if n.name == agent_name]\n    if not agents:\n        return []\n    agent = agents[0]\n\n    # Get encounters\n    encounters = [\n        n for n in graph.nodes(NodeType.ENCOUNTER)\n        if hasattr(n, 'agent_id') and str(n.agent_id) == str(agent.id)\n    ]\n\n    if len(encounters) &lt; 3:\n        print(f\"Not enough encounters ({len(encounters)}) to detect patterns\")\n        return []\n\n    # Detect practices\n    config = PracticeDetectionConfig(min_occurrences=3)\n    practices = detect_practices(encounters, agent.id, config)\n\n    # Categorize\n    routines = [p for p in practices if p.practice_type.name == \"ROUTINE\"]\n    habits = [p for p in practices if p.practice_type.name == \"HABIT\"]\n    rituals = [p for p in practices if p.practice_type.name == \"RITUAL\"]\n\n    print(f\"\\n\ud83d\udcca Analysis for {agent_name}\")\n    print(f\"   Total encounters: {len(encounters)}\")\n    print(f\"   Routines: {len(routines)}\")\n    print(f\"   Habits: {len(habits)}\")\n    print(f\"   Rituals: {len(rituals)}\")\n\n    return practices\n\n# Usage\npractices = analyze_routines(graph, \"alice\")\n</code></pre>"},{"location":"guides/practice-detection/#next-steps","title":"Next Steps","text":"<ul> <li>GPS to Places \u2014 Process location data first</li> <li>Affective Mapping \u2014 Add emotional context to routines</li> <li>Visualization \u2014 Visualize temporal patterns</li> </ul>"},{"location":"guides/streaming/","title":"Real-time Streaming","text":"<p>Process live GPS traces and detect place events in real-time.</p>"},{"location":"guides/streaming/#overview","title":"Overview","text":"<p>Chora isn't just for static files. The <code>streaming</code> module processes infinite streams of location data to: 1. Detect Dwells (stopping at a location) 2. Create Encounters (logging the visit) 3. Emit Events (WebSocket / WebHook)</p> <pre><code>sequenceDiagram\n    participant GPS as Device\n    participant Stream as StreamProcessor\n    participant Graph as PlatialGraph\n    participant Client as WebSocket Client\n\n    GPS-&gt;&gt;Stream: Location(lat, lon, t)\n    Stream-&gt;&gt;Stream: buffer &amp; filter\n\n    alt is dwelling &gt; 60s\n        Stream-&gt;&gt;Graph: create Encounter node\n        Stream-&gt;&gt;Client: emit \"encounter_start\"\n    end\n\n    alt is moving\n        Stream-&gt;&gt;Client: emit \"location_update\"\n    end</code></pre>"},{"location":"guides/streaming/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/streaming/#1-configure-processor","title":"1. Configure Processor","text":"<pre><code>from chora.streaming import StreamProcessor, StreamConfig\n\nconfig = StreamConfig(\n    dwell_radius_m=25.0,     # Stop within 25m circle\n    dwell_time_s=60.0,       # For at least 60 seconds\n    min_dwell_for_encounter=120.0  # Log encounter after 2 mins\n)\n\nprocessor = StreamProcessor(graph, config)\n</code></pre>"},{"location":"guides/streaming/#2-push-events","title":"2. Push Events","text":"<pre><code>from chora.streaming import LocationEvent\nfrom datetime import datetime\n\n# Incoming data (e.g. from MQTT, HTTP, Kafka)\nraw_point = {\"lat\": 51.5, \"lon\": -0.1, \"agent\": \"alice\"}\n\nevent = LocationEvent(\n    agent_id=raw_point[\"agent\"],\n    latitude=raw_point[\"lat\"],\n    longitude=raw_point[\"lon\"],\n    timestamp=datetime.now()\n)\n\n# Process returns list of consequential events (if any)\nnew_events = processor.process(event)\n\nfor e in new_events:\n    if e.event_type == \"encounter\":\n        print(f\"\ud83c\udfe0 Alice is at {e.data['extent_id']}\")\n</code></pre>"},{"location":"guides/streaming/#websocket-server","title":"WebSocket Server","text":"<p>Chora includes a WebSocket handler for FastAPI.</p> <pre><code># server.py\nfrom fastapi import FastAPI, WebSocket\nfrom chora.streaming import websocket_handler, create_processor\n\napp = FastAPI()\nprocessor = create_processor(graph)\n\n@app.websocket(\"/ws/stream\")\nasync def stream_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    await websocket_handler(websocket, processor)\n</code></pre> <p>Client Side (JS):</p> <pre><code>const ws = new WebSocket(\"ws://localhost:8000/ws/stream\");\n\n// Send location\nws.send(JSON.stringify({\n  type: \"location\",\n  agent_id: \"alice\",\n  latitude: 51.5074,\n  longitude: -0.1278,\n  timestamp: new Date().toISOString()\n}));\n\n// Listen for place events\nws.onmessage = (event) =&gt; {\n  const msg = JSON.parse(event.data);\n  if (msg.event_type === \"encounter\") {\n    console.log(\"You visited a place:\", msg.data);\n  }\n}\n</code></pre>"},{"location":"guides/streaming/#state-management","title":"State Management","text":"<p>The processor maintains state for each agent:</p> <pre><code>state = processor.get_agent_state(\"alice\")\n\nprint(f\"Current Status: {'Dwelling' if state.dwell_start else 'Moving'}\")\nif state.dwell_start:\n    duration = (now - state.dwell_start).total_seconds()\n    print(f\"Dwelling for: {duration}s\")\n</code></pre>"},{"location":"guides/streaming/#next-steps","title":"Next Steps","text":"<ul> <li>GPS to Places \u2014 Learn about the offline pipeline</li> <li>API Reference \u2014 Full streaming API docs</li> </ul>"},{"location":"guides/vibe-search/","title":"Semantic \"Vibe\" Search","text":"<p>Find places by their qualitative \"vibe\" rather than keywords or coordinates.</p>"},{"location":"guides/vibe-search/#what-is-vibe-search","title":"What is Vibe Search?","text":"<p>Traditional search finds \"coffee\" or \"gym\". Vibe search uses vector embeddings to understand the semantic meaning of places.</p> <p>It finds places that feel like your query, even if they don't contain the exact words.</p> <ul> <li>\"Quiet place to read\" -&gt; matches Parks, Libraries, Cozy Cafes</li> <li>\"Late night bonding\" -&gt; matches Pubs, 24/7 Diners, Rooftops</li> </ul>"},{"location":"guides/vibe-search/#how-it-works","title":"How It Works","text":"<ol> <li>Embed: Convert text (place names, hints, descriptions) into a vector.</li> <li>Index: Store place vectors.</li> <li>Query: Convert user query into a vector.</li> <li>Compare: Find nearest neighbors using cosine similarity.</li> </ol>"},{"location":"guides/vibe-search/#step-1-build-the-index","title":"Step 1: Build the Index","text":"<p>You need <code>sentence-transformers</code> installed.</p> <pre><code>from chora.core import PlatialGraph\nfrom chora.search import build_place_index, PlaceIndex\n\n# Load your populated graph\ngraph = PlatialGraph.load(\"my_city.json\")\n\n# Build index (computes embeddings for all places)\n# Uses 'all-MiniLM-L6-v2' by default (small &amp; fast)\nindex = build_place_index(graph)\n\n# Save for later\nindex.save(\"place_index.json\")\n</code></pre>"},{"location":"guides/vibe-search/#step-2-search-by-vibe","title":"Step 2: Search by Vibe","text":"<pre><code>from chora.search import vibe_search\n\n# Load index if needed\n# index = PlaceIndex.load(\"place_index.json\")\n\n# 1. Productive vibe\nresults = vibe_search(\n    graph, \n    \"place to get deep work done with coffee\",\n    index=index\n)\n\nfor extent, score in results[:3]:\n    print(f\"{score:.2f} | {extent.name} ({extent.extent_type})\")\n# 0.82 | Third Space Library (public)\n# 0.79 | Ozone Roasters (cafe)\n# 0.65 | WeWork Lobby (coworking)\n\n# 2. Romantic vibe\nresults = vibe_search(\n    graph,\n    \"romantic evening spot with a view\",\n    index=index\n)\n# 0.85 | Sky Garden (viewpoint)\n# 0.78 | Southbank Walk (path)\n</code></pre>"},{"location":"guides/vibe-search/#step-3-find-similar-places-recommendation","title":"Step 3: Find Similar Places (Recommendation)","text":"<p>\"If you like The Book Club, you might like...\"</p> <pre><code>from chora.search import find_similar_places\n\n# Get reference place\nbook_club = graph.get_node_by_name(\"The Book Club\")\n\n# Find lookalikes\nrecommendations = find_similar_places(\n    graph,\n    reference_extent=book_club,\n    top_k=3\n)\n</code></pre>"},{"location":"guides/vibe-search/#advanced-custom-embeddings","title":"Advanced: Custom Embeddings","text":"<p>You can enrich the embeddings by including more context:</p> <pre><code>from chora.search import embed_extent\n\n# Custom embedding that prioritizes \"activities\"\nembedding = embed_extent(\n    place, \n    graph, \n    include_encounters=True,  # Include \"visited 50 times\"\n    model_name=\"all-mpnet-base-v2\"  # Larger, more accurate model\n)\n</code></pre>"},{"location":"guides/vibe-search/#cli-usage","title":"CLI Usage","text":"<p>Currently available as a library function. CLI integration coming in v0.9.5.</p> <pre><code># Quick script\nfrom chora.cli import get_graph\nfrom chora.search import vibe_search\n\ngraph = get_graph()\nprint(vibe_search(graph, \"cozy spot\"))\n</code></pre>"},{"location":"guides/vibe-search/#next-steps","title":"Next Steps","text":"<ul> <li>H3 Indexing \u2014 Combine semantic search with spatial search</li> <li>LLM Integration \u2014 Generate descriptions for results</li> </ul>"},{"location":"guides/visualization/","title":"Visualization","text":"<p>Create interactive graphs, timelines, and HTML reports.</p>"},{"location":"guides/visualization/#d3js-force-graph","title":"D3.js Force Graph","text":"<p>Export your platial graph as an interactive force-directed visualization.</p>"},{"location":"guides/visualization/#quick-export","title":"Quick Export","text":"<pre><code>from chora.viz import export_force_graph\n\nexport_force_graph(\n    graph,\n    output_path=\"my_graph.html\",\n    title=\"My Place Network\"\n)\n</code></pre> <p>Opens in browser with: - Draggable nodes - Color-coded by type (Agent, Place, Encounter, etc.) - Click nodes for details - Legend and sidebar</p>"},{"location":"guides/visualization/#json-export-for-custom-d3","title":"JSON Export for Custom D3","text":"<pre><code>from chora.viz import export_d3_json\nimport json\n\ndata = export_d3_json(graph)\n# Returns: {\"nodes\": [...], \"links\": [...]}\n\nwith open(\"graph_data.json\", \"w\") as f:\n    json.dump(data, f, indent=2, default=str)\n</code></pre> <p>Node structure: <pre><code>{\n  \"id\": \"abc-123\",\n  \"type\": \"SPATIAL_EXTENT\",\n  \"name\": \"Coffee Shop\",\n  \"group\": 1\n}\n</code></pre></p>"},{"location":"guides/visualization/#timeline-visualization","title":"Timeline Visualization","text":"<p>Create interactive timelines of encounters over time.</p> <pre><code>from chora.viz import export_timeline_html\n\nexport_timeline_html(\n    graph,\n    agent_id=alice.id,\n    output_path=\"alice_timeline.html\",\n    title=\"Alice's Journey\"\n)\n</code></pre> <p>Features: - Chronological event display - Place labels and durations - Interactive filtering - Summary statistics</p>"},{"location":"guides/visualization/#html-reports","title":"HTML Reports","text":"<p>Generate comprehensive summary reports.</p> <pre><code>from chora.viz import generate_report\n\ngenerate_report(\n    graph,\n    output_path=\"report.html\",\n    title=\"Platial Analysis Report\"\n)\n</code></pre> <p>Report includes: - Graph statistics (nodes, edges by type) - Agent overview - Place inventory - Encounter summary - Interactive data tables</p>"},{"location":"guides/visualization/#cli-usage","title":"CLI Usage","text":"<pre><code># Export D3 graph\nchora viz export --format d3 --output graph.html\n\n# Export as JSON\nchora viz export --format json --output data.json\n\n# Export as DOT (Graphviz)\nchora viz export --format dot --output graph.dot\n\n# Generate timeline\nchora viz timeline --agent alice --output timeline.html\n</code></pre>"},{"location":"guides/visualization/#customization","title":"Customization","text":""},{"location":"guides/visualization/#custom-node-colors","title":"Custom Node Colors","text":"<pre><code>from chora.viz.d3_export import export_force_graph\n\n# Custom color scheme\ncolors = {\n    \"AGENT\": \"#e74c3c\",\n    \"SPATIAL_EXTENT\": \"#2ecc71\", \n    \"ENCOUNTER\": \"#f39c12\",\n    \"FAMILIARITY\": \"#9b59b6\",\n    \"AFFECT\": \"#1abc9c\"\n}\n\nexport_force_graph(\n    graph, \n    \"styled_graph.html\",\n    node_colors=colors\n)\n</code></pre>"},{"location":"guides/visualization/#embed-in-existing-html","title":"Embed in Existing HTML","text":"<pre><code>data = export_d3_json(graph)\n\n# Use in your own D3 code\nhtml = f\"\"\"\n&lt;script src=\"https://d3js.org/d3.v7.min.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\nconst data = {json.dumps(data)};\n// Your custom D3 visualization\n&lt;/script&gt;\n\"\"\"\n</code></pre>"},{"location":"guides/visualization/#complete-example","title":"Complete Example","text":"<pre><code>\"\"\"Full visualization workflow.\"\"\"\nfrom chora.core import PlatialGraph, Agent, SpatialExtent, Encounter, PlatialEdge\nfrom chora.viz import export_force_graph, export_timeline_html, generate_report\nfrom datetime import datetime, timedelta\n\n# Create sample graph\ngraph = PlatialGraph(name=\"demo\")\nalice = Agent.individual(\"alice\")\ngraph.add_node(alice)\n\nplaces = [\n    SpatialExtent.from_point(-0.1, 51.5, name=\"Home\"),\n    SpatialExtent.from_point(-0.08, 51.52, name=\"Work\"),\n    SpatialExtent.from_point(-0.09, 51.51, name=\"Park\"),\n]\n\nfor place in places:\n    graph.add_node(place)\n\n# Add encounters\nbase = datetime.now() - timedelta(days=7)\nfor i, place in enumerate(places):\n    enc = Encounter(\n        agent_id=alice.id,\n        extent_id=place.id,\n        start_time=base + timedelta(days=i),\n        activity=\"visit\"\n    )\n    graph.add_node(enc)\n    graph.add_edge(PlatialEdge.participates_in(alice.id, enc.id))\n    graph.add_edge(PlatialEdge.occurs_at(enc.id, place.id))\n\n# Generate all visualizations\nexport_force_graph(graph, \"output/graph.html\", \"Place Network\")\nexport_timeline_html(graph, alice.id, \"output/timeline.html\", \"Alice's Week\")\ngenerate_report(graph, \"output/report.html\", \"Analysis Summary\")\n\nprint(\"\u2713 Generated: graph.html, timeline.html, report.html\")\n</code></pre>"},{"location":"guides/visualization/#next-steps","title":"Next Steps","text":"<ul> <li>GPS to Places \u2014 Get data to visualize</li> <li>H3 Indexing \u2014 Hexagonal visualizations</li> <li>API Reference \u2014 Full viz module docs</li> </ul>"}]}